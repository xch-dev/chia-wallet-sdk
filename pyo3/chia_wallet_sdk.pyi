from typing import List, Optional, Union, Awaitable
from enum import IntEnum

ClvmType = Union[Program, PublicKey, Signature, K1PublicKey, K1Signature, R1PublicKey, R1Signature, Remark, AggSigParent, AggSigPuzzle, AggSigAmount, AggSigPuzzleAmount, AggSigParentAmount, AggSigParentPuzzle, AggSigUnsafe, AggSigMe, CreateCoin, ReserveFee, CreateCoinAnnouncement, CreatePuzzleAnnouncement, AssertCoinAnnouncement, AssertPuzzleAnnouncement, AssertConcurrentSpend, AssertConcurrentPuzzle, AssertSecondsRelative, AssertSecondsAbsolute, AssertHeightRelative, AssertHeightAbsolute, AssertBeforeSecondsRelative, AssertBeforeSecondsAbsolute, AssertBeforeHeightRelative, AssertBeforeHeightAbsolute, AssertMyCoinId, AssertMyParentId, AssertMyPuzzleHash, AssertMyAmount, AssertMyBirthSeconds, AssertMyBirthHeight, AssertEphemeral, SendMessage, ReceiveMessage, Softfork, Pair, NftMetadata, CurriedProgram, MipsMemo, InnerPuzzleMemo, RestrictionMemo, WrapperMemo, Force1of2RestrictedVariableMemo, MemoKind, MemberMemo, MofNMemo, MeltSingleton, TransferNft, RunCatTail, UpdateNftMetadata, UpdateDataStoreMerkleRoot, OptionMetadata, NotarizedPayment, Payment, str, int, bool, bytes, None, List['ClvmType']]

def m_of_n_hash(config: MemberConfig, required: int, items: List[bytes]) -> bytes: ...
def k1_member_hash(config: MemberConfig, publicKey: K1PublicKey, fastForward: bool) -> bytes: ...
def r1_member_hash(config: MemberConfig, publicKey: R1PublicKey, fastForward: bool) -> bytes: ...
def bls_member_hash(config: MemberConfig, publicKey: PublicKey) -> bytes: ...
def passkey_member_hash(config: MemberConfig, publicKey: R1PublicKey, fastForward: bool) -> bytes: ...
def singleton_member_hash(config: MemberConfig, launcherId: bytes) -> bytes: ...
def fixed_member_hash(config: MemberConfig, fixedPuzzleHash: bytes) -> bytes: ...
def custom_member_hash(config: MemberConfig, innerHash: bytes) -> bytes: ...
def timelock_restriction(timelock: int) -> Restriction: ...
def force_1_of_2_restriction(leftSideSubtreeHash: bytes, nonce: int, memberValidatorListHash: bytes, delegatedPuzzleValidatorListHash: bytes) -> Restriction: ...
def prevent_condition_opcode_restriction(conditionOpcode: int) -> Restriction: ...
def prevent_multiple_create_coins_restriction() -> Restriction: ...
def prevent_vault_side_effects_restriction() -> List[Restriction]: ...
def wrapped_delegated_puzzle_hash(restrictions: List[Restriction], delegatedPuzzleHash: bytes) -> bytes: ...
def encode_offer(spendBundle: SpendBundle) -> str: ...
def decode_offer(offer: str) -> SpendBundle: ...
def standard_puzzle_hash(syntheticKey: PublicKey) -> bytes: ...
def cat_puzzle_hash(assetId: bytes, innerPuzzleHash: bytes) -> bytes: ...
def from_hex(value: str) -> bytes: ...
def to_hex(value: bytes) -> str: ...
def bytes_equal(lhs: bytes, rhs: bytes) -> bool: ...
def tree_hash_atom(atom: bytes) -> bytes: ...
def tree_hash_pair(first: bytes, rest: bytes) -> bytes: ...
def sha256(value: bytes) -> bytes: ...
def curry_tree_hash(program: bytes, args: List[bytes]) -> bytes: ...
def generate_bytes(bytes: int) -> bytes: ...

class Address:
    def clone(self) -> Address: ...
    def __init__(self, puzzleHash: bytes, prefix: str) -> None: ...
    puzzle_hash: bytes
    prefix: str
    def encode(self) -> str: ...
    @staticmethod
    def decode(address: str) -> Address: ...
class SecretKey:
    def clone(self) -> SecretKey: ...
    @staticmethod
    def from_seed(seed: bytes) -> SecretKey: ...
    @staticmethod
    def from_bytes(bytes: bytes) -> SecretKey: ...
    def to_bytes(self) -> bytes: ...
    def public_key(self) -> PublicKey: ...
    def sign(self, message: bytes) -> Signature: ...
    def derive_unhardened(self, index: int) -> SecretKey: ...
    def derive_hardened(self, index: int) -> SecretKey: ...
    def derive_unhardened_path(self, path: List[int]) -> SecretKey: ...
    def derive_hardened_path(self, path: List[int]) -> SecretKey: ...
    def derive_synthetic(self) -> SecretKey: ...
    def derive_synthetic_hidden(self, hiddenPuzzleHash: bytes) -> SecretKey: ...
class PublicKey:
    def clone(self) -> PublicKey: ...
    @staticmethod
    def infinity() -> PublicKey: ...
    @staticmethod
    def aggregate(publicKeys: List[PublicKey]) -> PublicKey: ...
    @staticmethod
    def aggregate_verify(publicKeys: List[PublicKey], messages: List[bytes], signature: Signature) -> bool: ...
    @staticmethod
    def from_bytes(bytes: bytes) -> PublicKey: ...
    def to_bytes(self) -> bytes: ...
    def verify(self, message: bytes, signature: Signature) -> bool: ...
    def fingerprint(self) -> int: ...
    def is_infinity(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def derive_unhardened(self, index: int) -> PublicKey: ...
    def derive_unhardened_path(self, path: List[int]) -> PublicKey: ...
    def derive_synthetic(self) -> PublicKey: ...
    def derive_synthetic_hidden(self, hiddenPuzzleHash: bytes) -> PublicKey: ...
class Signature:
    def clone(self) -> Signature: ...
    @staticmethod
    def infinity() -> Signature: ...
    @staticmethod
    def aggregate(signatures: List[Signature]) -> Signature: ...
    @staticmethod
    def from_bytes(bytes: bytes) -> Signature: ...
    def to_bytes(self) -> bytes: ...
    def is_infinity(self) -> bool: ...
    def is_valid(self) -> bool: ...
class Clvm:
    def clone(self) -> Clvm: ...
    def __init__(self) -> None: ...
    def add_coin_spend(self, coinSpend: CoinSpend) -> None: ...
    def spend_coin(self, coin: Coin, spend: Spend) -> None: ...
    def coin_spends(self) -> List[CoinSpend]: ...
    def parse(self, program: str) -> Program: ...
    def deserialize(self, value: bytes) -> Program: ...
    def deserialize_with_backrefs(self, value: bytes) -> Program: ...
    def cache(self, modHash: bytes, value: bytes) -> Program: ...
    def alloc(self, value: ClvmType) -> Program: ...
    def pair(self, first: Program, rest: Program) -> Program: ...
    def nil(self) -> Program: ...
    def int(self, value: int) -> Program: ...
    def bound_checked_number(self, value: float) -> Program: ...
    def string(self, value: str) -> Program: ...
    def bool(self, value: bool) -> Program: ...
    def atom(self, value: bytes) -> Program: ...
    def list(self, value: List[Program]) -> Program: ...
    def delegated_spend(self, conditions: List[Program]) -> Spend: ...
    def standard_spend(self, syntheticKey: PublicKey, spend: Spend) -> Spend: ...
    def spend_standard_coin(self, coin: Coin, syntheticKey: PublicKey, spend: Spend) -> None: ...
    def settlement_spend(self, notarizedPayments: List[NotarizedPayment]) -> Spend: ...
    def spend_settlement_coin(self, coin: Coin, notarizedPayments: List[NotarizedPayment]) -> None: ...
    def spend_cats(self, catSpends: List[CatSpend]) -> List[Cat]: ...
    def mint_nfts(self, parentCoinId: bytes, nftMints: List[NftMint]) -> MintedNfts: ...
    def spend_nft(self, nft: Nft, innerSpend: Spend) -> Nft: ...
    def create_eve_did(self, parentCoinId: bytes, p2PuzzleHash: bytes) -> CreatedDid: ...
    def spend_did(self, did: Did, innerSpend: Spend) -> Optional[Did]: ...
    def spend_option(self, option: OptionContract, innerSpend: Spend) -> Optional[OptionContract]: ...
    def spend_streamed_asset(self, streamedAsset: StreamedAsset, paymentTime: int, clawback: bool) -> None: ...
    def mint_vault(self, parentCoinId: bytes, custodyHash: bytes, memos: Program) -> VaultMint: ...
    def mips_spend(self, coin: Coin, delegatedSpend: Spend) -> MipsSpend: ...
    def nft_metadata(self, value: NftMetadata) -> Program: ...
    def mips_memo(self, value: MipsMemo) -> Program: ...
    def inner_puzzle_memo(self, value: InnerPuzzleMemo) -> Program: ...
    def restriction_memo(self, value: RestrictionMemo) -> Program: ...
    def wrapper_memo(self, value: WrapperMemo) -> Program: ...
    def force_1_of_2_restricted_variable_memo(self, value: Force1of2RestrictedVariableMemo) -> Program: ...
    def memo_kind(self, value: MemoKind) -> Program: ...
    def member_memo(self, value: MemberMemo) -> Program: ...
    def m_of_n_memo(self, value: MofNMemo) -> Program: ...
    def remark(self, rest: Program) -> Program: ...
    def agg_sig_parent(self, publicKey: PublicKey, message: bytes) -> Program: ...
    def agg_sig_puzzle(self, publicKey: PublicKey, message: bytes) -> Program: ...
    def agg_sig_amount(self, publicKey: PublicKey, message: bytes) -> Program: ...
    def agg_sig_puzzle_amount(self, publicKey: PublicKey, message: bytes) -> Program: ...
    def agg_sig_parent_amount(self, publicKey: PublicKey, message: bytes) -> Program: ...
    def agg_sig_parent_puzzle(self, publicKey: PublicKey, message: bytes) -> Program: ...
    def agg_sig_unsafe(self, publicKey: PublicKey, message: bytes) -> Program: ...
    def agg_sig_me(self, publicKey: PublicKey, message: bytes) -> Program: ...
    def create_coin(self, puzzleHash: bytes, amount: int, memos: Optional[Program] = None) -> Program: ...
    def reserve_fee(self, amount: int) -> Program: ...
    def create_coin_announcement(self, message: bytes) -> Program: ...
    def create_puzzle_announcement(self, message: bytes) -> Program: ...
    def assert_coin_announcement(self, announcementId: bytes) -> Program: ...
    def assert_puzzle_announcement(self, announcementId: bytes) -> Program: ...
    def assert_concurrent_spend(self, coinId: bytes) -> Program: ...
    def assert_concurrent_puzzle(self, puzzleHash: bytes) -> Program: ...
    def assert_seconds_relative(self, seconds: int) -> Program: ...
    def assert_seconds_absolute(self, seconds: int) -> Program: ...
    def assert_height_relative(self, height: int) -> Program: ...
    def assert_height_absolute(self, height: int) -> Program: ...
    def assert_before_seconds_relative(self, seconds: int) -> Program: ...
    def assert_before_seconds_absolute(self, seconds: int) -> Program: ...
    def assert_before_height_relative(self, height: int) -> Program: ...
    def assert_before_height_absolute(self, height: int) -> Program: ...
    def assert_my_coin_id(self, coinId: bytes) -> Program: ...
    def assert_my_parent_id(self, parentId: bytes) -> Program: ...
    def assert_my_puzzle_hash(self, puzzleHash: bytes) -> Program: ...
    def assert_my_amount(self, amount: int) -> Program: ...
    def assert_my_birth_seconds(self, seconds: int) -> Program: ...
    def assert_my_birth_height(self, height: int) -> Program: ...
    def assert_ephemeral(self) -> Program: ...
    def send_message(self, mode: int, message: bytes, data: List[Program]) -> Program: ...
    def receive_message(self, mode: int, message: bytes, data: List[Program]) -> Program: ...
    def softfork(self, cost: int, rest: Program) -> Program: ...
    def melt_singleton(self) -> Program: ...
    def transfer_nft(self, launcherId: Optional[bytes], tradePrices: List[TradePrice], singletonInnerPuzzleHash: Optional[bytes] = None) -> Program: ...
    def run_cat_tail(self, program: Program, solution: Program) -> Program: ...
    def update_nft_metadata(self, updaterPuzzleReveal: Program, updaterSolution: Program) -> Program: ...
    def update_data_store_merkle_root(self, newMerkleRoot: bytes, memos: List[bytes]) -> Program: ...
    def parse_child_streamed_asset(self, coinSpend: CoinSpend) -> StreamedAssetParsingResult: ...
    def parse_child_medieval_vault(self, coinSpend: CoinSpend) -> Optional[MedievalVault]: ...
    def spend_medieval_vault(self, medievalVault: MedievalVault, usedPubkeys: List[PublicKey], conditions: List[Program], genesisChallenge: bytes) -> None: ...
    def spend_medieval_vault_unsafe(self, medievalVault: MedievalVault, usedPubkeys: List[PublicKey], delegatedSpend: Spend) -> None: ...
    def medieval_vault_rekey_delegated_puzzle(self, launcherId: bytes, newM: usize, newPubkeys: List[PublicKey], coinId: bytes, genesisChallenge: bytes) -> Program: ...
    def medieval_vault_send_message_delegated_puzzle(self, message: bytes, receiverLauncherId: bytes, myCoin: Coin, myInfo: MedievalVaultInfo, genesisChallenge: bytes) -> Program: ...
    def reward_distributor_from_spend(self, spend: CoinSpend, reserveLineageProof: Optional[LineageProof], constants: RewardDistributorConstants) -> Optional[RewardDistributor]: ...
    def reward_distributor_from_parent_spend(self, parentSpend: CoinSpend, constants: RewardDistributorConstants) -> Optional[RewardDistributor]: ...
    def reward_distributor_from_eve_coin_spend(self, constants: RewardDistributorConstants, initialState: RewardDistributorState, eveCoinSpend: CoinSpend, reserveParentId: bytes, reserveLineageProof: LineageProof) -> Optional[RewardDistributorInfoFromEveCoin]: ...
    def launch_reward_distributor(self, offer: SpendBundle, firstEpochStart: int, catRefundPuzzleHash: bytes, constants: RewardDistributorConstants, mainnet: bool, comment: str) -> RewardDistributorLaunchResult: ...
    def create_offer_security_coin(self, offer: SpendBundle) -> OfferSecurityCoinDetails: ...
    def spend_offer_security_coin(self, securityCoinDetails: OfferSecurityCoinDetails, conditions: List[Program], mainnet: bool) -> Signature: ...
    def spend_settlement_nft(self, offer: SpendBundle, nftLauncherId: bytes, nonce: bytes, destinationPuzzleHash: bytes) -> SettlementNftSpendResult: ...
    def offer_settlement_cats(self, offer: SpendBundle, assetId: bytes) -> List[Cat]: ...
    def offer_settlement_nft(self, offer: SpendBundle, nftLauncherId: bytes) -> Optional[Nft]: ...
    def acs_transfer_program(self) -> Program: ...
    def augmented_condition(self) -> Program: ...
    def block_program_zero(self) -> Program: ...
    def cat_puzzle(self) -> Program: ...
    def chialisp_deserialisation(self) -> Program: ...
    def conditions_w_fee_announce(self) -> Program: ...
    def covenant_layer(self) -> Program: ...
    def create_nft_launcher_from_did(self) -> Program: ...
    def credential_restriction(self) -> Program: ...
    def dao_cat_eve(self) -> Program: ...
    def dao_cat_launcher(self) -> Program: ...
    def dao_finished_state(self) -> Program: ...
    def dao_lockup(self) -> Program: ...
    def dao_proposal(self) -> Program: ...
    def dao_proposal_timer(self) -> Program: ...
    def dao_proposal_validator(self) -> Program: ...
    def dao_spend_p2_singleton(self) -> Program: ...
    def dao_treasury(self) -> Program: ...
    def dao_update_proposal(self) -> Program: ...
    def decompress_coin_spend_entry(self) -> Program: ...
    def decompress_coin_spend_entry_with_prefix(self) -> Program: ...
    def decompress_puzzle(self) -> Program: ...
    def delegated_tail(self) -> Program: ...
    def did_innerpuzzle(self) -> Program: ...
    def eml_covenant_morpher(self) -> Program: ...
    def eml_transfer_program_covenant_adapter(self) -> Program: ...
    def eml_update_metadata_with_did(self) -> Program: ...
    def everything_with_signature(self) -> Program: ...
    def exigent_metadata_layer(self) -> Program: ...
    def flag_proofs_checker(self) -> Program: ...
    def genesis_by_coin_id(self) -> Program: ...
    def genesis_by_coin_id_or_singleton(self) -> Program: ...
    def genesis_by_puzzle_hash(self) -> Program: ...
    def graftroot_dl_offers(self) -> Program: ...
    def nft_intermediate_launcher(self) -> Program: ...
    def nft_metadata_updater_default(self) -> Program: ...
    def nft_metadata_updater_updateable(self) -> Program: ...
    def nft_ownership_layer(self) -> Program: ...
    def nft_ownership_transfer_program_one_way_claim_with_royalties(self) -> Program: ...
    def nft_state_layer(self) -> Program: ...
    def notification(self) -> Program: ...
    def p2_1_of_n(self) -> Program: ...
    def p2_announced_delegated_puzzle(self) -> Program: ...
    def p2_conditions(self) -> Program: ...
    def p2_delegated_conditions(self) -> Program: ...
    def p2_delegated_puzzle(self) -> Program: ...
    def p2_delegated_puzzle_or_hidden_puzzle(self) -> Program: ...
    def p2_m_of_n_delegate_direct(self) -> Program: ...
    def p2_parent(self) -> Program: ...
    def p2_puzzle_hash(self) -> Program: ...
    def p2_singleton(self) -> Program: ...
    def p2_singleton_aggregator(self) -> Program: ...
    def p2_singleton_or_delayed_puzzle_hash(self) -> Program: ...
    def p2_singleton_via_delegated_puzzle(self) -> Program: ...
    def pool_member_innerpuzzle(self) -> Program: ...
    def pool_waitingroom_innerpuzzle(self) -> Program: ...
    def revocation_layer(self) -> Program: ...
    def rom_bootstrap_generator(self) -> Program: ...
    def settlement_payment(self) -> Program: ...
    def singleton_launcher(self) -> Program: ...
    def singleton_top_layer(self) -> Program: ...
    def singleton_top_layer_v1_1(self) -> Program: ...
    def standard_vc_revocation_puzzle(self) -> Program: ...
    def std_parent_morpher(self) -> Program: ...
    def option_contract(self) -> Program: ...
    def p2_curried_puzzle(self) -> Program: ...
    def bls_member(self) -> Program: ...
    def bls_taproot_member(self) -> Program: ...
    def fixed_puzzle_member(self) -> Program: ...
    def k1_member_puzzle_assert(self) -> Program: ...
    def k1_member(self) -> Program: ...
    def passkey_member_puzzle_assert(self) -> Program: ...
    def passkey_member(self) -> Program: ...
    def r1_member_puzzle_assert(self) -> Program: ...
    def r1_member(self) -> Program: ...
    def singleton_member(self) -> Program: ...
    def enforce_delegated_puzzle_wrappers(self) -> Program: ...
    def force_1_of_2_restricted_variable(self) -> Program: ...
    def force_assert_coin_announcement(self) -> Program: ...
    def force_coin_message(self) -> Program: ...
    def prevent_condition_opcode(self) -> Program: ...
    def prevent_multiple_create_coins(self) -> Program: ...
    def timelock(self) -> Program: ...
    def add_delegated_puzzle_wrapper(self) -> Program: ...
    def delegated_puzzle_feeder(self) -> Program: ...
    def restrictions(self) -> Program: ...
    def index_wrapper(self) -> Program: ...
    def m_of_n(self) -> Program: ...
    def n_of_n(self) -> Program: ...
    def one_of_n(self) -> Program: ...
class Output:
    def clone(self) -> Output: ...
    def __init__(self, value: Program, cost: int) -> None: ...
    value: Program
    cost: int
class Pair:
    def clone(self) -> Pair: ...
    def __init__(self, first: Program, rest: Program) -> None: ...
    first: Program
    rest: Program
class CurriedProgram:
    def clone(self) -> CurriedProgram: ...
    def __init__(self, program: Program, args: List[Program]) -> None: ...
    program: Program
    args: List[Program]
class Proof:
    def clone(self) -> Proof: ...
    def __init__(self, parentParentCoinInfo: bytes, parentInnerPuzzleHash: Optional[bytes], parentAmount: int) -> None: ...
    parent_parent_coin_info: bytes
    parent_inner_puzzle_hash: Optional[bytes]
    parent_amount: int
    def to_lineage_proof(self) -> Optional[LineageProof]: ...
class LineageProof:
    def clone(self) -> LineageProof: ...
    def __init__(self, parentParentCoinInfo: bytes, parentInnerPuzzleHash: bytes, parentAmount: int) -> None: ...
    parent_parent_coin_info: bytes
    parent_inner_puzzle_hash: bytes
    parent_amount: int
    def to_proof(self) -> Proof: ...
class OfferSecurityCoinDetails:
    def clone(self) -> OfferSecurityCoinDetails: ...
    def __init__(self, securityCoin: Coin, securityCoinSk: SecretKey) -> None: ...
    security_coin: Coin
    security_coin_sk: SecretKey
class SettlementNftSpendResult:
    def clone(self) -> SettlementNftSpendResult: ...
    def __init__(self, newNft: Nft, securityConditions: List[Program]) -> None: ...
    new_nft: Nft
    security_conditions: List[Program]
class Coin:
    def clone(self) -> Coin: ...
    def __init__(self, parentCoinInfo: bytes, puzzleHash: bytes, amount: int) -> None: ...
    parent_coin_info: bytes
    puzzle_hash: bytes
    amount: int
    def coin_id(self) -> bytes: ...
class CoinSpend:
    def clone(self) -> CoinSpend: ...
    def __init__(self, coin: Coin, puzzleReveal: bytes, solution: bytes) -> None: ...
    coin: Coin
    puzzle_reveal: bytes
    solution: bytes
class SpendBundle:
    def clone(self) -> SpendBundle: ...
    def __init__(self, coinSpends: List[CoinSpend], aggregatedSignature: Signature) -> None: ...
    coin_spends: List[CoinSpend]
    aggregated_signature: Signature
    def to_bytes(self) -> bytes: ...
    @staticmethod
    def from_bytes(bytes: bytes) -> SpendBundle: ...
    def hash(self) -> bytes: ...
class Spend:
    def clone(self) -> Spend: ...
    def __init__(self, puzzle: Program, solution: Program) -> None: ...
    puzzle: Program
    solution: Program
class CoinsetClient:
    def clone(self) -> CoinsetClient: ...
    def __init__(self, baseUrl: str) -> None: ...
    @staticmethod
    def testnet11() -> CoinsetClient: ...
    @staticmethod
    def mainnet() -> CoinsetClient: ...
    async def get_blockchain_state(self) -> Awaitable[BlockchainStateResponse]: ...
    async def get_additions_and_removals(self, headerHash: bytes) -> Awaitable[AdditionsAndRemovalsResponse]: ...
    async def get_block(self, headerHash: bytes) -> Awaitable[GetBlockResponse]: ...
    async def get_block_record(self, headerHash: bytes) -> Awaitable[GetBlockRecordResponse]: ...
    async def get_block_record_by_height(self, height: int) -> Awaitable[GetBlockRecordResponse]: ...
    async def get_block_records(self, startHeight: int, endHeight: int) -> Awaitable[GetBlockRecordsResponse]: ...
    async def get_blocks(self, start: int, end: int, excludeHeaderHash: bool, excludeReorged: bool) -> Awaitable[GetBlocksResponse]: ...
    async def get_block_spends(self, headerHash: bytes) -> Awaitable[GetBlockSpendsResponse]: ...
    async def get_coin_record_by_name(self, name: bytes) -> Awaitable[GetCoinRecordResponse]: ...
    async def get_coin_records_by_hint(self, hint: bytes, startHeight: Optional[int] = None, endHeight: Optional[int] = None, includeSpentCoins: Optional[bool] = None) -> Awaitable[GetCoinRecordsResponse]: ...
    async def get_coin_records_by_hints(self, hints: List[bytes], startHeight: Optional[int] = None, endHeight: Optional[int] = None, includeSpentCoins: Optional[bool] = None) -> Awaitable[GetCoinRecordsResponse]: ...
    async def get_coin_records_by_names(self, names: List[bytes], startHeight: Optional[int] = None, endHeight: Optional[int] = None, includeSpentCoins: Optional[bool] = None) -> Awaitable[GetCoinRecordsResponse]: ...
    async def get_coin_records_by_parent_ids(self, parentIds: List[bytes], startHeight: Optional[int] = None, endHeight: Optional[int] = None, includeSpentCoins: Optional[bool] = None) -> Awaitable[GetCoinRecordsResponse]: ...
    async def get_coin_records_by_puzzle_hash(self, puzzleHash: bytes, startHeight: Optional[int] = None, endHeight: Optional[int] = None, includeSpentCoins: Optional[bool] = None) -> Awaitable[GetCoinRecordsResponse]: ...
    async def get_coin_records_by_puzzle_hashes(self, puzzleHashes: List[bytes], startHeight: Optional[int] = None, endHeight: Optional[int] = None, includeSpentCoins: Optional[bool] = None) -> Awaitable[GetCoinRecordsResponse]: ...
    async def get_puzzle_and_solution(self, coinId: bytes, height: Optional[int] = None) -> Awaitable[GetPuzzleAndSolutionResponse]: ...
    async def push_tx(self, spendBundle: SpendBundle) -> Awaitable[PushTxResponse]: ...
    async def get_network_info(self) -> Awaitable[GetNetworkInfoResponse]: ...
    async def get_mempool_item_by_tx_id(self, txId: bytes) -> Awaitable[GetMempoolItemResponse]: ...
    async def get_mempool_items_by_coin_name(self, coinName: bytes) -> Awaitable[GetMempoolItemsResponse]: ...
class BlockchainStateResponse:
    def clone(self) -> BlockchainStateResponse: ...
    def __init__(self, blockchainState: Optional[BlockchainState], error: Optional[str], success: bool) -> None: ...
    blockchain_state: Optional[BlockchainState]
    error: Optional[str]
    success: bool
class BlockchainState:
    def clone(self) -> BlockchainState: ...
    def __init__(self, averageBlockTime: int, blockMaxCost: int, difficulty: int, genesisChallengeInitialized: bool, mempoolCost: int, mempoolFees: int, mempoolMaxTotalCost: int, mempoolMinFees: MempoolMinFees, mempoolSize: int, nodeId: bytes, peak: BlockRecord, space: int, subSlotIters: int, sync: SyncState) -> None: ...
    average_block_time: int
    block_max_cost: int
    difficulty: int
    genesis_challenge_initialized: bool
    mempool_cost: int
    mempool_fees: int
    mempool_max_total_cost: int
    mempool_min_fees: MempoolMinFees
    mempool_size: int
    node_id: bytes
    peak: BlockRecord
    space: int
    sub_slot_iters: int
    sync: SyncState
class MempoolMinFees:
    def clone(self) -> MempoolMinFees: ...
    def __init__(self, cost5000000: int) -> None: ...
    cost_5000000: int
class SyncState:
    def clone(self) -> SyncState: ...
    def __init__(self, syncMode: bool, syncProgressHeight: int, syncTipHeight: int, synced: bool) -> None: ...
    sync_mode: bool
    sync_progress_height: int
    sync_tip_height: int
    synced: bool
class AdditionsAndRemovalsResponse:
    def clone(self) -> AdditionsAndRemovalsResponse: ...
    def __init__(self, additions: Optional[List[CoinRecord]], removals: Optional[List[CoinRecord]], error: Optional[str], success: bool) -> None: ...
    additions: Optional[List[CoinRecord]]
    removals: Optional[List[CoinRecord]]
    error: Optional[str]
    success: bool
class GetBlockResponse:
    def clone(self) -> GetBlockResponse: ...
    def __init__(self, block: Optional[FullBlock], error: Optional[str], success: bool) -> None: ...
    block: Optional[FullBlock]
    error: Optional[str]
    success: bool
class GetBlockRecordResponse:
    def clone(self) -> GetBlockRecordResponse: ...
    def __init__(self, blockRecord: Optional[BlockRecord], error: Optional[str], success: bool) -> None: ...
    block_record: Optional[BlockRecord]
    error: Optional[str]
    success: bool
class GetBlockRecordsResponse:
    def clone(self) -> GetBlockRecordsResponse: ...
    def __init__(self, blockRecords: Optional[List[BlockRecord]], error: Optional[str], success: bool) -> None: ...
    block_records: Optional[List[BlockRecord]]
    error: Optional[str]
    success: bool
class GetBlocksResponse:
    def clone(self) -> GetBlocksResponse: ...
    def __init__(self, blocks: Optional[List[FullBlock]], error: Optional[str], success: bool) -> None: ...
    blocks: Optional[List[FullBlock]]
    error: Optional[str]
    success: bool
class GetBlockSpendsResponse:
    def clone(self) -> GetBlockSpendsResponse: ...
    def __init__(self, blockSpends: Optional[List[CoinSpend]], error: Optional[str], success: bool) -> None: ...
    block_spends: Optional[List[CoinSpend]]
    error: Optional[str]
    success: bool
class GetCoinRecordResponse:
    def clone(self) -> GetCoinRecordResponse: ...
    def __init__(self, coinRecord: Optional[CoinRecord], error: Optional[str], success: bool) -> None: ...
    coin_record: Optional[CoinRecord]
    error: Optional[str]
    success: bool
class GetCoinRecordsResponse:
    def clone(self) -> GetCoinRecordsResponse: ...
    def __init__(self, coinRecords: Optional[List[CoinRecord]], error: Optional[str], success: bool) -> None: ...
    coin_records: Optional[List[CoinRecord]]
    error: Optional[str]
    success: bool
class GetPuzzleAndSolutionResponse:
    def clone(self) -> GetPuzzleAndSolutionResponse: ...
    def __init__(self, coinSolution: Optional[CoinSpend], error: Optional[str], success: bool) -> None: ...
    coin_solution: Optional[CoinSpend]
    error: Optional[str]
    success: bool
class PushTxResponse:
    def clone(self) -> PushTxResponse: ...
    def __init__(self, status: str, error: Optional[str], success: bool) -> None: ...
    status: str
    error: Optional[str]
    success: bool
class GetNetworkInfoResponse:
    def clone(self) -> GetNetworkInfoResponse: ...
    def __init__(self, networkName: Optional[str], networkPrefix: Optional[str], genesisChallenge: Optional[bytes], error: Optional[str], success: bool) -> None: ...
    network_name: Optional[str]
    network_prefix: Optional[str]
    genesis_challenge: Optional[bytes]
    error: Optional[str]
    success: bool
class GetMempoolItemResponse:
    def clone(self) -> GetMempoolItemResponse: ...
    def __init__(self, mempoolItem: Optional[MempoolItem], error: Optional[str], success: bool) -> None: ...
    mempool_item: Optional[MempoolItem]
    error: Optional[str]
    success: bool
class GetMempoolItemsResponse:
    def clone(self) -> GetMempoolItemsResponse: ...
    def __init__(self, mempoolItems: Optional[List[MempoolItem]], error: Optional[str], success: bool) -> None: ...
    mempool_items: Optional[List[MempoolItem]]
    error: Optional[str]
    success: bool
class CoinRecord:
    def clone(self) -> CoinRecord: ...
    def __init__(self, coin: Coin, coinbase: bool, confirmedBlockIndex: int, spent: bool, spentBlockIndex: int, timestamp: int) -> None: ...
    coin: Coin
    coinbase: bool
    confirmed_block_index: int
    spent: bool
    spent_block_index: int
    timestamp: int
class MempoolItem:
    def clone(self) -> MempoolItem: ...
    def __init__(self, spendBundle: SpendBundle, fee: int) -> None: ...
    spend_bundle: SpendBundle
    fee: int
class FullBlock:
    def clone(self) -> FullBlock: ...
    def __init__(self, finishedSubSlots: List[EndOfSubSlotBundle], rewardChainBlock: RewardChainBlock, challengeChainSpProof: Optional[VDFProof], challengeChainIpProof: VDFProof, rewardChainSpProof: Optional[VDFProof], rewardChainIpProof: VDFProof, infusedChallengeChainIpProof: Optional[VDFProof], foliage: Foliage, foliageTransactionBlock: Optional[FoliageTransactionBlock], transactionsInfo: Optional[TransactionsInfo], transactionsGenerator: Optional[bytes], transactionsGeneratorRefList: List[int]) -> None: ...
    finished_sub_slots: List[EndOfSubSlotBundle]
    reward_chain_block: RewardChainBlock
    challenge_chain_sp_proof: Optional[VDFProof]
    challenge_chain_ip_proof: VDFProof
    reward_chain_sp_proof: Optional[VDFProof]
    reward_chain_ip_proof: VDFProof
    infused_challenge_chain_ip_proof: Optional[VDFProof]
    foliage: Foliage
    foliage_transaction_block: Optional[FoliageTransactionBlock]
    transactions_info: Optional[TransactionsInfo]
    transactions_generator: Optional[bytes]
    transactions_generator_ref_list: List[int]
class EndOfSubSlotBundle:
    def clone(self) -> EndOfSubSlotBundle: ...
    def __init__(self, challengeChain: ChallengeChainSubSlot, infusedChallengeChain: Optional[InfusedChallengeChainSubSlot], rewardChain: RewardChainSubSlot, proofs: SubSlotProofs) -> None: ...
    challenge_chain: ChallengeChainSubSlot
    infused_challenge_chain: Optional[InfusedChallengeChainSubSlot]
    reward_chain: RewardChainSubSlot
    proofs: SubSlotProofs
class ChallengeChainSubSlot:
    def clone(self) -> ChallengeChainSubSlot: ...
    def __init__(self, challengeChainEndOfSlotVdf: VDFInfo, infusedChallengeChainSubSlotHash: Optional[bytes] = None, subepochSummaryHash: Optional[bytes] = None, newSubSlotIters: Optional[int] = None, newDifficulty: Optional[int] = None) -> None: ...
    challenge_chain_end_of_slot_vdf: VDFInfo
    infused_challenge_chain_sub_slot_hash: Optional[bytes]
    subepoch_summary_hash: Optional[bytes]
    new_sub_slot_iters: Optional[int]
    new_difficulty: Optional[int]
class InfusedChallengeChainSubSlot:
    def clone(self) -> InfusedChallengeChainSubSlot: ...
    def __init__(self, infusedChallengeChainEndOfSlotVdf: VDFInfo) -> None: ...
    infused_challenge_chain_end_of_slot_vdf: VDFInfo
class RewardChainSubSlot:
    def clone(self) -> RewardChainSubSlot: ...
    def __init__(self, endOfSlotVdf: VDFInfo, challengeChainSubSlotHash: bytes, infusedChallengeChainSubSlotHash: Optional[bytes], deficit: int) -> None: ...
    end_of_slot_vdf: VDFInfo
    challenge_chain_sub_slot_hash: bytes
    infused_challenge_chain_sub_slot_hash: Optional[bytes]
    deficit: int
class SubSlotProofs:
    def clone(self) -> SubSlotProofs: ...
    def __init__(self, challengeChainSlotProof: VDFProof, infusedChallengeChainSlotProof: Optional[VDFProof], rewardChainSlotProof: VDFProof) -> None: ...
    challenge_chain_slot_proof: VDFProof
    infused_challenge_chain_slot_proof: Optional[VDFProof]
    reward_chain_slot_proof: VDFProof
class VDFInfo:
    def clone(self) -> VDFInfo: ...
    def __init__(self, challenge: bytes, numberOfIterations: int, output: bytes) -> None: ...
    challenge: bytes
    number_of_iterations: int
    output: bytes
class VDFProof:
    def clone(self) -> VDFProof: ...
    def __init__(self, witnessType: int, witness: bytes, normalizedToIdentity: bool) -> None: ...
    witness_type: int
    witness: bytes
    normalized_to_identity: bool
class TransactionsInfo:
    def clone(self) -> TransactionsInfo: ...
    def __init__(self, generatorRoot: bytes, generatorRefsRoot: bytes, aggregatedSignature: Signature, fees: int, cost: int, rewardClaimsIncorporated: List[Coin]) -> None: ...
    generator_root: bytes
    generator_refs_root: bytes
    aggregated_signature: Signature
    fees: int
    cost: int
    reward_claims_incorporated: List[Coin]
class RewardChainBlock:
    def clone(self) -> RewardChainBlock: ...
    def __init__(self, weight: int, height: int, totalIters: int, signagePointIndex: int, posSsCcChallengeHash: bytes, proofOfSpace: ProofOfSpace, challengeChainSpVdf: Optional[VDFInfo], challengeChainSpSignature: Signature, challengeChainIpVdf: VDFInfo, rewardChainSpVdf: Optional[VDFInfo], rewardChainSpSignature: Signature, rewardChainIpVdf: VDFInfo, infusedChallengeChainIpVdf: Optional[VDFInfo], isTransactionBlock: bool) -> None: ...
    weight: int
    height: int
    total_iters: int
    signage_point_index: int
    pos_ss_cc_challenge_hash: bytes
    proof_of_space: ProofOfSpace
    challenge_chain_sp_vdf: Optional[VDFInfo]
    challenge_chain_sp_signature: Signature
    challenge_chain_ip_vdf: VDFInfo
    reward_chain_sp_vdf: Optional[VDFInfo]
    reward_chain_sp_signature: Signature
    reward_chain_ip_vdf: VDFInfo
    infused_challenge_chain_ip_vdf: Optional[VDFInfo]
    is_transaction_block: bool
class FoliageTransactionBlock:
    def clone(self) -> FoliageTransactionBlock: ...
    def __init__(self, prevTransactionBlockHash: bytes, timestamp: int, filterHash: bytes, additionsRoot: bytes, removalsRoot: bytes, transactionsInfoHash: bytes) -> None: ...
    prev_transaction_block_hash: bytes
    timestamp: int
    filter_hash: bytes
    additions_root: bytes
    removals_root: bytes
    transactions_info_hash: bytes
class FoliageBlockData:
    def clone(self) -> FoliageBlockData: ...
    def __init__(self, unfinishedRewardBlockHash: bytes, poolTarget: PoolTarget, poolSignature: Optional[Signature], farmerRewardPuzzleHash: bytes, extensionData: bytes) -> None: ...
    unfinished_reward_block_hash: bytes
    pool_target: PoolTarget
    pool_signature: Optional[Signature]
    farmer_reward_puzzle_hash: bytes
    extension_data: bytes
class Foliage:
    def clone(self) -> Foliage: ...
    def __init__(self, prevBlockHash: bytes, rewardBlockHash: bytes, foliageBlockData: FoliageBlockData, foliageBlockDataSignature: Signature, foliageTransactionBlockHash: Optional[bytes] = None, foliageTransactionBlockSignature: Optional[Signature] = None) -> None: ...
    prev_block_hash: bytes
    reward_block_hash: bytes
    foliage_block_data: FoliageBlockData
    foliage_block_data_signature: Signature
    foliage_transaction_block_hash: Optional[bytes]
    foliage_transaction_block_signature: Optional[Signature]
class PoolTarget:
    def clone(self) -> PoolTarget: ...
    def __init__(self, puzzleHash: bytes, maxHeight: int) -> None: ...
    puzzle_hash: bytes
    max_height: int
class BlockRecord:
    def clone(self) -> BlockRecord: ...
    def __init__(self, headerHash: bytes, prevHash: bytes, height: int, weight: int, totalIters: int, signagePointIndex: int, challengeVdfOutput: bytes, infusedChallengeVdfOutput: Optional[bytes], rewardInfusionNewChallenge: bytes, challengeBlockInfoHash: bytes, subSlotIters: int, poolPuzzleHash: bytes, farmerPuzzleHash: bytes, requiredIters: int, deficit: int, overflow: bool, prevTransactionBlockHeight: int, timestamp: Optional[int] = None, prevTransactionBlockHash: Optional[bytes] = None, fees: Optional[int] = None, rewardClaimsIncorporated: Optional[List[Coin]] = None, finishedChallengeSlotHashes: Optional[List[bytes]] = None, finishedInfusedChallengeSlotHashes: Optional[List[bytes]] = None, finishedRewardSlotHashes: Optional[List[bytes]] = None, subEpochSummaryIncluded: Optional[SubEpochSummary] = None) -> None: ...
    header_hash: bytes
    prev_hash: bytes
    height: int
    weight: int
    total_iters: int
    signage_point_index: int
    challenge_vdf_output: bytes
    infused_challenge_vdf_output: Optional[bytes]
    reward_infusion_new_challenge: bytes
    challenge_block_info_hash: bytes
    sub_slot_iters: int
    pool_puzzle_hash: bytes
    farmer_puzzle_hash: bytes
    required_iters: int
    deficit: int
    overflow: bool
    prev_transaction_block_height: int
    timestamp: Optional[int]
    prev_transaction_block_hash: Optional[bytes]
    fees: Optional[int]
    reward_claims_incorporated: Optional[List[Coin]]
    finished_challenge_slot_hashes: Optional[List[bytes]]
    finished_infused_challenge_slot_hashes: Optional[List[bytes]]
    finished_reward_slot_hashes: Optional[List[bytes]]
    sub_epoch_summary_included: Optional[SubEpochSummary]
class ProofOfSpace:
    def clone(self) -> ProofOfSpace: ...
    def __init__(self, challenge: bytes, poolPublicKey: Optional[PublicKey], poolContractPuzzleHash: Optional[bytes], plotPublicKey: PublicKey, versionAndSize: int, proof: bytes) -> None: ...
    challenge: bytes
    pool_public_key: Optional[PublicKey]
    pool_contract_puzzle_hash: Optional[bytes]
    plot_public_key: PublicKey
    version_and_size: int
    proof: bytes
class SubEpochSummary:
    def clone(self) -> SubEpochSummary: ...
    def __init__(self, prevSubepochSummaryHash: bytes, rewardChainHash: bytes, numBlocksOverflow: int, newDifficulty: Optional[int] = None, newSubSlotIters: Optional[int] = None) -> None: ...
    prev_subepoch_summary_hash: bytes
    reward_chain_hash: bytes
    num_blocks_overflow: int
    new_difficulty: Optional[int]
    new_sub_slot_iters: Optional[int]
class Remark:
    def clone(self) -> Remark: ...
    def __init__(self, rest: Program) -> None: ...
    rest: Program
class AggSigParent:
    def clone(self) -> AggSigParent: ...
    def __init__(self, publicKey: PublicKey, message: bytes) -> None: ...
    public_key: PublicKey
    message: bytes
class AggSigPuzzle:
    def clone(self) -> AggSigPuzzle: ...
    def __init__(self, publicKey: PublicKey, message: bytes) -> None: ...
    public_key: PublicKey
    message: bytes
class AggSigAmount:
    def clone(self) -> AggSigAmount: ...
    def __init__(self, publicKey: PublicKey, message: bytes) -> None: ...
    public_key: PublicKey
    message: bytes
class AggSigPuzzleAmount:
    def clone(self) -> AggSigPuzzleAmount: ...
    def __init__(self, publicKey: PublicKey, message: bytes) -> None: ...
    public_key: PublicKey
    message: bytes
class AggSigParentAmount:
    def clone(self) -> AggSigParentAmount: ...
    def __init__(self, publicKey: PublicKey, message: bytes) -> None: ...
    public_key: PublicKey
    message: bytes
class AggSigParentPuzzle:
    def clone(self) -> AggSigParentPuzzle: ...
    def __init__(self, publicKey: PublicKey, message: bytes) -> None: ...
    public_key: PublicKey
    message: bytes
class AggSigUnsafe:
    def clone(self) -> AggSigUnsafe: ...
    def __init__(self, publicKey: PublicKey, message: bytes) -> None: ...
    public_key: PublicKey
    message: bytes
class AggSigMe:
    def clone(self) -> AggSigMe: ...
    def __init__(self, publicKey: PublicKey, message: bytes) -> None: ...
    public_key: PublicKey
    message: bytes
class CreateCoin:
    def clone(self) -> CreateCoin: ...
    def __init__(self, puzzleHash: bytes, amount: int, memos: Optional[Program] = None) -> None: ...
    puzzle_hash: bytes
    amount: int
    memos: Optional[Program]
class ReserveFee:
    def clone(self) -> ReserveFee: ...
    def __init__(self, amount: int) -> None: ...
    amount: int
class CreateCoinAnnouncement:
    def clone(self) -> CreateCoinAnnouncement: ...
    def __init__(self, message: bytes) -> None: ...
    message: bytes
class CreatePuzzleAnnouncement:
    def clone(self) -> CreatePuzzleAnnouncement: ...
    def __init__(self, message: bytes) -> None: ...
    message: bytes
class AssertCoinAnnouncement:
    def clone(self) -> AssertCoinAnnouncement: ...
    def __init__(self, announcementId: bytes) -> None: ...
    announcement_id: bytes
class AssertPuzzleAnnouncement:
    def clone(self) -> AssertPuzzleAnnouncement: ...
    def __init__(self, announcementId: bytes) -> None: ...
    announcement_id: bytes
class AssertConcurrentSpend:
    def clone(self) -> AssertConcurrentSpend: ...
    def __init__(self, coinId: bytes) -> None: ...
    coin_id: bytes
class AssertConcurrentPuzzle:
    def clone(self) -> AssertConcurrentPuzzle: ...
    def __init__(self, puzzleHash: bytes) -> None: ...
    puzzle_hash: bytes
class AssertSecondsRelative:
    def clone(self) -> AssertSecondsRelative: ...
    def __init__(self, seconds: int) -> None: ...
    seconds: int
class AssertSecondsAbsolute:
    def clone(self) -> AssertSecondsAbsolute: ...
    def __init__(self, seconds: int) -> None: ...
    seconds: int
class AssertHeightRelative:
    def clone(self) -> AssertHeightRelative: ...
    def __init__(self, height: int) -> None: ...
    height: int
class AssertHeightAbsolute:
    def clone(self) -> AssertHeightAbsolute: ...
    def __init__(self, height: int) -> None: ...
    height: int
class AssertBeforeSecondsRelative:
    def clone(self) -> AssertBeforeSecondsRelative: ...
    def __init__(self, seconds: int) -> None: ...
    seconds: int
class AssertBeforeSecondsAbsolute:
    def clone(self) -> AssertBeforeSecondsAbsolute: ...
    def __init__(self, seconds: int) -> None: ...
    seconds: int
class AssertBeforeHeightRelative:
    def clone(self) -> AssertBeforeHeightRelative: ...
    def __init__(self, height: int) -> None: ...
    height: int
class AssertBeforeHeightAbsolute:
    def clone(self) -> AssertBeforeHeightAbsolute: ...
    def __init__(self, height: int) -> None: ...
    height: int
class AssertMyCoinId:
    def clone(self) -> AssertMyCoinId: ...
    def __init__(self, coinId: bytes) -> None: ...
    coin_id: bytes
class AssertMyParentId:
    def clone(self) -> AssertMyParentId: ...
    def __init__(self, parentId: bytes) -> None: ...
    parent_id: bytes
class AssertMyPuzzleHash:
    def clone(self) -> AssertMyPuzzleHash: ...
    def __init__(self, puzzleHash: bytes) -> None: ...
    puzzle_hash: bytes
class AssertMyAmount:
    def clone(self) -> AssertMyAmount: ...
    def __init__(self, amount: int) -> None: ...
    amount: int
class AssertMyBirthSeconds:
    def clone(self) -> AssertMyBirthSeconds: ...
    def __init__(self, seconds: int) -> None: ...
    seconds: int
class AssertMyBirthHeight:
    def clone(self) -> AssertMyBirthHeight: ...
    def __init__(self, height: int) -> None: ...
    height: int
class AssertEphemeral:
    def clone(self) -> AssertEphemeral: ...
    def __init__(self, ) -> None: ...
class SendMessage:
    def clone(self) -> SendMessage: ...
    def __init__(self, mode: int, message: bytes, data: List[Program]) -> None: ...
    mode: int
    message: bytes
    data: List[Program]
class ReceiveMessage:
    def clone(self) -> ReceiveMessage: ...
    def __init__(self, mode: int, message: bytes, data: List[Program]) -> None: ...
    mode: int
    message: bytes
    data: List[Program]
class Softfork:
    def clone(self) -> Softfork: ...
    def __init__(self, cost: int, rest: Program) -> None: ...
    cost: int
    rest: Program
class MeltSingleton:
    def clone(self) -> MeltSingleton: ...
    def __init__(self, ) -> None: ...
class TransferNft:
    def clone(self) -> TransferNft: ...
    def __init__(self, launcherId: Optional[bytes], tradePrices: List[TradePrice], singletonInnerPuzzleHash: Optional[bytes] = None) -> None: ...
    launcher_id: Optional[bytes]
    trade_prices: List[TradePrice]
    singleton_inner_puzzle_hash: Optional[bytes]
class RunCatTail:
    def clone(self) -> RunCatTail: ...
    def __init__(self, program: Program, solution: Program) -> None: ...
    program: Program
    solution: Program
class UpdateNftMetadata:
    def clone(self) -> UpdateNftMetadata: ...
    def __init__(self, updaterPuzzleReveal: Program, updaterSolution: Program) -> None: ...
    updater_puzzle_reveal: Program
    updater_solution: Program
class UpdateDataStoreMerkleRoot:
    def clone(self) -> UpdateDataStoreMerkleRoot: ...
    def __init__(self, newMerkleRoot: bytes, memos: List[bytes]) -> None: ...
    new_merkle_root: bytes
    memos: List[bytes]
class TradePrice:
    def clone(self) -> TradePrice: ...
    def __init__(self, amount: int, puzzleHash: bytes) -> None: ...
    amount: int
    puzzle_hash: bytes
class Constants:
    def clone(self) -> Constants: ...
    @staticmethod
    def acs_transfer_program() -> bytes: ...
    @staticmethod
    def acs_transfer_program_hash() -> bytes: ...
    @staticmethod
    def augmented_condition() -> bytes: ...
    @staticmethod
    def augmented_condition_hash() -> bytes: ...
    @staticmethod
    def block_program_zero() -> bytes: ...
    @staticmethod
    def block_program_zero_hash() -> bytes: ...
    @staticmethod
    def cat_puzzle() -> bytes: ...
    @staticmethod
    def cat_puzzle_hash() -> bytes: ...
    @staticmethod
    def chialisp_deserialisation() -> bytes: ...
    @staticmethod
    def chialisp_deserialisation_hash() -> bytes: ...
    @staticmethod
    def conditions_w_fee_announce() -> bytes: ...
    @staticmethod
    def conditions_w_fee_announce_hash() -> bytes: ...
    @staticmethod
    def covenant_layer() -> bytes: ...
    @staticmethod
    def covenant_layer_hash() -> bytes: ...
    @staticmethod
    def create_nft_launcher_from_did() -> bytes: ...
    @staticmethod
    def create_nft_launcher_from_did_hash() -> bytes: ...
    @staticmethod
    def credential_restriction() -> bytes: ...
    @staticmethod
    def credential_restriction_hash() -> bytes: ...
    @staticmethod
    def dao_cat_eve() -> bytes: ...
    @staticmethod
    def dao_cat_eve_hash() -> bytes: ...
    @staticmethod
    def dao_cat_launcher() -> bytes: ...
    @staticmethod
    def dao_cat_launcher_hash() -> bytes: ...
    @staticmethod
    def dao_finished_state() -> bytes: ...
    @staticmethod
    def dao_finished_state_hash() -> bytes: ...
    @staticmethod
    def dao_lockup() -> bytes: ...
    @staticmethod
    def dao_lockup_hash() -> bytes: ...
    @staticmethod
    def dao_proposal() -> bytes: ...
    @staticmethod
    def dao_proposal_hash() -> bytes: ...
    @staticmethod
    def dao_proposal_timer() -> bytes: ...
    @staticmethod
    def dao_proposal_timer_hash() -> bytes: ...
    @staticmethod
    def dao_proposal_validator() -> bytes: ...
    @staticmethod
    def dao_proposal_validator_hash() -> bytes: ...
    @staticmethod
    def dao_spend_p2_singleton() -> bytes: ...
    @staticmethod
    def dao_spend_p2_singleton_hash() -> bytes: ...
    @staticmethod
    def dao_treasury() -> bytes: ...
    @staticmethod
    def dao_treasury_hash() -> bytes: ...
    @staticmethod
    def dao_update_proposal() -> bytes: ...
    @staticmethod
    def dao_update_proposal_hash() -> bytes: ...
    @staticmethod
    def decompress_coin_spend_entry() -> bytes: ...
    @staticmethod
    def decompress_coin_spend_entry_hash() -> bytes: ...
    @staticmethod
    def decompress_coin_spend_entry_with_prefix() -> bytes: ...
    @staticmethod
    def decompress_coin_spend_entry_with_prefix_hash() -> bytes: ...
    @staticmethod
    def decompress_puzzle() -> bytes: ...
    @staticmethod
    def decompress_puzzle_hash() -> bytes: ...
    @staticmethod
    def delegated_tail() -> bytes: ...
    @staticmethod
    def delegated_tail_hash() -> bytes: ...
    @staticmethod
    def did_innerpuzzle() -> bytes: ...
    @staticmethod
    def did_innerpuzzle_hash() -> bytes: ...
    @staticmethod
    def eml_covenant_morpher() -> bytes: ...
    @staticmethod
    def eml_covenant_morpher_hash() -> bytes: ...
    @staticmethod
    def eml_transfer_program_covenant_adapter() -> bytes: ...
    @staticmethod
    def eml_transfer_program_covenant_adapter_hash() -> bytes: ...
    @staticmethod
    def eml_update_metadata_with_did() -> bytes: ...
    @staticmethod
    def eml_update_metadata_with_did_hash() -> bytes: ...
    @staticmethod
    def everything_with_signature() -> bytes: ...
    @staticmethod
    def everything_with_signature_hash() -> bytes: ...
    @staticmethod
    def exigent_metadata_layer() -> bytes: ...
    @staticmethod
    def exigent_metadata_layer_hash() -> bytes: ...
    @staticmethod
    def flag_proofs_checker() -> bytes: ...
    @staticmethod
    def flag_proofs_checker_hash() -> bytes: ...
    @staticmethod
    def genesis_by_coin_id() -> bytes: ...
    @staticmethod
    def genesis_by_coin_id_hash() -> bytes: ...
    @staticmethod
    def genesis_by_coin_id_or_singleton() -> bytes: ...
    @staticmethod
    def genesis_by_coin_id_or_singleton_hash() -> bytes: ...
    @staticmethod
    def genesis_by_puzzle_hash() -> bytes: ...
    @staticmethod
    def genesis_by_puzzle_hash_hash() -> bytes: ...
    @staticmethod
    def graftroot_dl_offers() -> bytes: ...
    @staticmethod
    def graftroot_dl_offers_hash() -> bytes: ...
    @staticmethod
    def nft_intermediate_launcher() -> bytes: ...
    @staticmethod
    def nft_intermediate_launcher_hash() -> bytes: ...
    @staticmethod
    def nft_metadata_updater_default() -> bytes: ...
    @staticmethod
    def nft_metadata_updater_default_hash() -> bytes: ...
    @staticmethod
    def nft_metadata_updater_updateable() -> bytes: ...
    @staticmethod
    def nft_metadata_updater_updateable_hash() -> bytes: ...
    @staticmethod
    def nft_ownership_layer() -> bytes: ...
    @staticmethod
    def nft_ownership_layer_hash() -> bytes: ...
    @staticmethod
    def nft_ownership_transfer_program_one_way_claim_with_royalties() -> bytes: ...
    @staticmethod
    def nft_ownership_transfer_program_one_way_claim_with_royalties_hash() -> bytes: ...
    @staticmethod
    def nft_state_layer() -> bytes: ...
    @staticmethod
    def nft_state_layer_hash() -> bytes: ...
    @staticmethod
    def notification() -> bytes: ...
    @staticmethod
    def notification_hash() -> bytes: ...
    @staticmethod
    def p2_1_of_n() -> bytes: ...
    @staticmethod
    def p2_1_of_n_hash() -> bytes: ...
    @staticmethod
    def p2_announced_delegated_puzzle() -> bytes: ...
    @staticmethod
    def p2_announced_delegated_puzzle_hash() -> bytes: ...
    @staticmethod
    def p2_conditions() -> bytes: ...
    @staticmethod
    def p2_conditions_hash() -> bytes: ...
    @staticmethod
    def p2_delegated_conditions() -> bytes: ...
    @staticmethod
    def p2_delegated_conditions_hash() -> bytes: ...
    @staticmethod
    def p2_delegated_puzzle() -> bytes: ...
    @staticmethod
    def p2_delegated_puzzle_hash() -> bytes: ...
    @staticmethod
    def p2_delegated_puzzle_or_hidden_puzzle() -> bytes: ...
    @staticmethod
    def p2_delegated_puzzle_or_hidden_puzzle_hash() -> bytes: ...
    @staticmethod
    def p2_m_of_n_delegate_direct() -> bytes: ...
    @staticmethod
    def p2_m_of_n_delegate_direct_hash() -> bytes: ...
    @staticmethod
    def p2_parent() -> bytes: ...
    @staticmethod
    def p2_parent_hash() -> bytes: ...
    @staticmethod
    def p2_puzzle_hash() -> bytes: ...
    @staticmethod
    def p2_puzzle_hash_hash() -> bytes: ...
    @staticmethod
    def p2_singleton() -> bytes: ...
    @staticmethod
    def p2_singleton_hash() -> bytes: ...
    @staticmethod
    def p2_singleton_aggregator() -> bytes: ...
    @staticmethod
    def p2_singleton_aggregator_hash() -> bytes: ...
    @staticmethod
    def p2_singleton_or_delayed_puzzle_hash() -> bytes: ...
    @staticmethod
    def p2_singleton_or_delayed_puzzle_hash_hash() -> bytes: ...
    @staticmethod
    def p2_singleton_via_delegated_puzzle() -> bytes: ...
    @staticmethod
    def p2_singleton_via_delegated_puzzle_hash() -> bytes: ...
    @staticmethod
    def pool_member_innerpuzzle() -> bytes: ...
    @staticmethod
    def pool_member_innerpuzzle_hash() -> bytes: ...
    @staticmethod
    def pool_waitingroom_innerpuzzle() -> bytes: ...
    @staticmethod
    def pool_waitingroom_innerpuzzle_hash() -> bytes: ...
    @staticmethod
    def revocation_layer() -> bytes: ...
    @staticmethod
    def revocation_layer_hash() -> bytes: ...
    @staticmethod
    def rom_bootstrap_generator() -> bytes: ...
    @staticmethod
    def rom_bootstrap_generator_hash() -> bytes: ...
    @staticmethod
    def settlement_payment() -> bytes: ...
    @staticmethod
    def settlement_payment_hash() -> bytes: ...
    @staticmethod
    def singleton_launcher() -> bytes: ...
    @staticmethod
    def singleton_launcher_hash() -> bytes: ...
    @staticmethod
    def singleton_top_layer() -> bytes: ...
    @staticmethod
    def singleton_top_layer_hash() -> bytes: ...
    @staticmethod
    def singleton_top_layer_v1_1() -> bytes: ...
    @staticmethod
    def singleton_top_layer_v1_1_hash() -> bytes: ...
    @staticmethod
    def standard_vc_revocation_puzzle() -> bytes: ...
    @staticmethod
    def standard_vc_revocation_puzzle_hash() -> bytes: ...
    @staticmethod
    def std_parent_morpher() -> bytes: ...
    @staticmethod
    def std_parent_morpher_hash() -> bytes: ...
    @staticmethod
    def option_contract() -> bytes: ...
    @staticmethod
    def option_contract_hash() -> bytes: ...
    @staticmethod
    def p2_curried_puzzle() -> bytes: ...
    @staticmethod
    def p2_curried_puzzle_hash() -> bytes: ...
    @staticmethod
    def bls_member() -> bytes: ...
    @staticmethod
    def bls_member_hash() -> bytes: ...
    @staticmethod
    def bls_taproot_member() -> bytes: ...
    @staticmethod
    def bls_taproot_member_hash() -> bytes: ...
    @staticmethod
    def fixed_puzzle_member() -> bytes: ...
    @staticmethod
    def fixed_puzzle_member_hash() -> bytes: ...
    @staticmethod
    def k1_member_puzzle_assert() -> bytes: ...
    @staticmethod
    def k1_member_puzzle_assert_hash() -> bytes: ...
    @staticmethod
    def k1_member() -> bytes: ...
    @staticmethod
    def k1_member_hash() -> bytes: ...
    @staticmethod
    def passkey_member_puzzle_assert() -> bytes: ...
    @staticmethod
    def passkey_member_puzzle_assert_hash() -> bytes: ...
    @staticmethod
    def passkey_member() -> bytes: ...
    @staticmethod
    def passkey_member_hash() -> bytes: ...
    @staticmethod
    def r1_member_puzzle_assert() -> bytes: ...
    @staticmethod
    def r1_member_puzzle_assert_hash() -> bytes: ...
    @staticmethod
    def r1_member() -> bytes: ...
    @staticmethod
    def r1_member_hash() -> bytes: ...
    @staticmethod
    def singleton_member() -> bytes: ...
    @staticmethod
    def singleton_member_hash() -> bytes: ...
    @staticmethod
    def enforce_delegated_puzzle_wrappers() -> bytes: ...
    @staticmethod
    def enforce_delegated_puzzle_wrappers_hash() -> bytes: ...
    @staticmethod
    def force_1_of_2_restricted_variable() -> bytes: ...
    @staticmethod
    def force_1_of_2_restricted_variable_hash() -> bytes: ...
    @staticmethod
    def force_assert_coin_announcement() -> bytes: ...
    @staticmethod
    def force_assert_coin_announcement_hash() -> bytes: ...
    @staticmethod
    def force_coin_message() -> bytes: ...
    @staticmethod
    def force_coin_message_hash() -> bytes: ...
    @staticmethod
    def prevent_condition_opcode() -> bytes: ...
    @staticmethod
    def prevent_condition_opcode_hash() -> bytes: ...
    @staticmethod
    def prevent_multiple_create_coins() -> bytes: ...
    @staticmethod
    def prevent_multiple_create_coins_hash() -> bytes: ...
    @staticmethod
    def timelock() -> bytes: ...
    @staticmethod
    def timelock_hash() -> bytes: ...
    @staticmethod
    def add_delegated_puzzle_wrapper() -> bytes: ...
    @staticmethod
    def add_delegated_puzzle_wrapper_hash() -> bytes: ...
    @staticmethod
    def delegated_puzzle_feeder() -> bytes: ...
    @staticmethod
    def delegated_puzzle_feeder_hash() -> bytes: ...
    @staticmethod
    def restrictions() -> bytes: ...
    @staticmethod
    def restrictions_hash() -> bytes: ...
    @staticmethod
    def index_wrapper() -> bytes: ...
    @staticmethod
    def index_wrapper_hash() -> bytes: ...
    @staticmethod
    def m_of_n() -> bytes: ...
    @staticmethod
    def m_of_n_hash() -> bytes: ...
    @staticmethod
    def n_of_n() -> bytes: ...
    @staticmethod
    def n_of_n_hash() -> bytes: ...
    @staticmethod
    def one_of_n() -> bytes: ...
    @staticmethod
    def one_of_n_hash() -> bytes: ...
class Vault:
    def clone(self) -> Vault: ...
    def __init__(self, coin: Coin, proof: Proof, info: VaultInfo) -> None: ...
    coin: Coin
    proof: Proof
    info: VaultInfo
    def child(self, custodyHash: bytes, amount: int) -> Vault: ...
class VaultInfo:
    def clone(self) -> VaultInfo: ...
    def __init__(self, launcherId: bytes, custodyHash: bytes) -> None: ...
    launcher_id: bytes
    custody_hash: bytes
class MemberConfig:
    def clone(self) -> MemberConfig: ...
    top_level: bool
    nonce: int
    restrictions: List[Restriction]
    def __init__(self) -> None: ...
    def with_top_level(self, topLevel: bool) -> MemberConfig: ...
    def with_nonce(self, nonce: int) -> MemberConfig: ...
    def with_restrictions(self, restrictions: List[Restriction]) -> MemberConfig: ...
class Restriction:
    def clone(self) -> Restriction: ...
    def __init__(self, kind: RestrictionKind, puzzleHash: bytes) -> None: ...
    kind: RestrictionKind
    puzzle_hash: bytes
class RestrictionKind(IntEnum):
    MemberCondition = 0
    DelegatedPuzzleHash = 1
    DelegatedPuzzleWrapper = 2
class MipsSpend:
    def clone(self) -> MipsSpend: ...
    def spend(self, custodyHash: bytes) -> Spend: ...
    def spend_vault(self, vault: Vault) -> None: ...
    def m_of_n(self, config: MemberConfig, required: int, items: List[bytes]) -> None: ...
    def k1_member(self, config: MemberConfig, publicKey: K1PublicKey, signature: K1Signature, fastForward: bool) -> None: ...
    def r1_member(self, config: MemberConfig, publicKey: R1PublicKey, signature: R1Signature, fastForward: bool) -> None: ...
    def bls_member(self, config: MemberConfig, publicKey: PublicKey) -> None: ...
    def passkey_member(self, config: MemberConfig, publicKey: R1PublicKey, signature: R1Signature, authenticatorData: bytes, clientDataJson: bytes, challengeIndex: int, fastForward: bool) -> None: ...
    def singleton_member(self, config: MemberConfig, launcherId: bytes, singletonInnerPuzzleHash: bytes, singletonAmount: int) -> None: ...
    def fixed_puzzle_member(self, config: MemberConfig, fixedPuzzleHash: bytes) -> None: ...
    def custom_member(self, config: MemberConfig, spend: Spend) -> None: ...
    def timelock(self, timelock: int) -> None: ...
    def force_1_of_2_restricted_variable(self, leftSideSubtreeHash: bytes, nonce: int, memberValidatorListHash: bytes, delegatedPuzzleValidatorListHash: bytes, newRightSideMemberHash: bytes) -> None: ...
    def prevent_condition_opcode(self, conditionOpcode: int) -> None: ...
    def prevent_multiple_create_coins(self) -> None: ...
    def prevent_vault_side_effects(self) -> None: ...
class VaultMint:
    def clone(self) -> VaultMint: ...
    def __init__(self, vault: Vault, parentConditions: List[Program]) -> None: ...
    vault: Vault
    parent_conditions: List[Program]
class MipsMemo:
    def clone(self) -> MipsMemo: ...
    def __init__(self, innerPuzzle: InnerPuzzleMemo) -> None: ...
    inner_puzzle: InnerPuzzleMemo
class InnerPuzzleMemo:
    def clone(self) -> InnerPuzzleMemo: ...
    def __init__(self, nonce: int, restrictions: List[RestrictionMemo], kind: MemoKind) -> None: ...
    nonce: int
    restrictions: List[RestrictionMemo]
    kind: MemoKind
class RestrictionMemo:
    def clone(self) -> RestrictionMemo: ...
    def __init__(self, memberConditionValidator: bool, puzzleHash: bytes, memo: Program) -> None: ...
    member_condition_validator: bool
    puzzle_hash: bytes
    memo: Program
    @staticmethod
    def force_1_of_2_restricted_variable(clvm: Clvm, leftSideSubtreeHash: bytes, nonce: int, memberValidatorListHash: bytes, delegatedPuzzleValidatorListHash: bytes) -> RestrictionMemo: ...
    @staticmethod
    def enforce_delegated_puzzle_wrappers(clvm: Clvm, wrapperMemos: List[WrapperMemo]) -> RestrictionMemo: ...
    @staticmethod
    def timelock(clvm: Clvm, seconds: int, reveal: bool) -> RestrictionMemo: ...
class WrapperMemo:
    def clone(self) -> WrapperMemo: ...
    def __init__(self, puzzleHash: bytes, memo: Program) -> None: ...
    puzzle_hash: bytes
    memo: Program
    @staticmethod
    def prevent_vault_side_effects(clvm: Clvm, reveal: bool) -> List[WrapperMemo]: ...
    @staticmethod
    def force_coin_announcement(clvm: Clvm) -> WrapperMemo: ...
    @staticmethod
    def force_coin_message(clvm: Clvm) -> WrapperMemo: ...
    @staticmethod
    def prevent_multiple_create_coins(clvm: Clvm) -> WrapperMemo: ...
    @staticmethod
    def timelock(clvm: Clvm, seconds: int, reveal: bool) -> WrapperMemo: ...
    @staticmethod
    def prevent_condition_opcode(clvm: Clvm, opcode: int, reveal: bool) -> WrapperMemo: ...
class Force1of2RestrictedVariableMemo:
    def clone(self) -> Force1of2RestrictedVariableMemo: ...
    def __init__(self, leftSideSubtreeHash: bytes, nonce: int, memberValidatorListHash: bytes, delegatedPuzzleValidatorListHash: bytes) -> None: ...
    left_side_subtree_hash: bytes
    nonce: int
    member_validator_list_hash: bytes
    delegated_puzzle_validator_list_hash: bytes
class MemoKind:
    def clone(self) -> MemoKind: ...
    @staticmethod
    def member(member: MemberMemo) -> MemoKind: ...
    @staticmethod
    def m_of_n(mOfN: MofNMemo) -> MemoKind: ...
    def as_member(self) -> Optional[MemberMemo]: ...
    def as_m_of_n(self) -> Optional[MofNMemo]: ...
class MemberMemo:
    def clone(self) -> MemberMemo: ...
    def __init__(self, puzzleHash: bytes, memo: Program) -> None: ...
    puzzle_hash: bytes
    memo: Program
    @staticmethod
    def k1(clvm: Clvm, publicKey: K1PublicKey, fastForward: bool, reveal: bool) -> MemberMemo: ...
    @staticmethod
    def r1(clvm: Clvm, publicKey: R1PublicKey, fastForward: bool, reveal: bool) -> MemberMemo: ...
    @staticmethod
    def bls(clvm: Clvm, publicKey: PublicKey, taproot: bool, reveal: bool) -> MemberMemo: ...
    @staticmethod
    def passkey(clvm: Clvm, publicKey: R1PublicKey, fastForward: bool, reveal: bool) -> MemberMemo: ...
    @staticmethod
    def singleton(clvm: Clvm, launcherId: bytes, reveal: bool) -> MemberMemo: ...
    @staticmethod
    def fixed_puzzle(clvm: Clvm, puzzleHash: bytes, reveal: bool) -> MemberMemo: ...
class MofNMemo:
    def clone(self) -> MofNMemo: ...
    def __init__(self, required: int, items: List[InnerPuzzleMemo]) -> None: ...
    required: int
    items: List[InnerPuzzleMemo]
class Mnemonic:
    def clone(self) -> Mnemonic: ...
    def __init__(self, mnemonic: str) -> None: ...
    @staticmethod
    def from_entropy(entropy: bytes) -> Mnemonic: ...
    @staticmethod
    def generate(use24: bool) -> Mnemonic: ...
    @staticmethod
    def verify(mnemonic: str) -> bool: ...
    def to_string(self) -> str: ...
    def to_entropy(self) -> bytes: ...
    def to_seed(self, password: str) -> bytes: ...
class NotarizedPayment:
    def clone(self) -> NotarizedPayment: ...
    def __init__(self, nonce: bytes, payments: List[Payment]) -> None: ...
    nonce: bytes
    payments: List[Payment]
class Payment:
    def clone(self) -> Payment: ...
    def __init__(self, puzzleHash: bytes, amount: int, memos: Optional[Program] = None) -> None: ...
    puzzle_hash: bytes
    amount: int
    memos: Optional[Program]
class Certificate:
    def clone(self) -> Certificate: ...
    def __init__(self, certPem: str, keyPem: str) -> None: ...
    cert_pem: str
    key_pem: str
    @staticmethod
    def load(certPath: str, keyPath: str) -> Certificate: ...
    @staticmethod
    def generate() -> Certificate: ...
class Connector:
    def clone(self) -> Connector: ...
    def __init__(self, cert: Certificate) -> None: ...
class PeerOptions:
    def clone(self) -> PeerOptions: ...
    rate_limit_factor: float
    def __init__(self) -> PeerOptions: ...
class Peer:
    def clone(self) -> Peer: ...
    @staticmethod
    async def connect(networkId: str, socketAddr: str, connector: Connector, options: PeerOptions) -> Awaitable[Peer]: ...
    async def request_coin_state(self, coinIds: List[bytes], previousHeight: Optional[int], headerHash: bytes, subscribe: bool) -> Awaitable[RespondCoinState]: ...
    async def request_puzzle_state(self, puzzleHashes: List[bytes], previousHeight: Optional[int], headerHash: bytes, filters: CoinStateFilters, subscribe: bool) -> Awaitable[RespondPuzzleState]: ...
    async def request_puzzle_and_solution(self, coinId: bytes, height: int) -> Awaitable[PuzzleSolutionResponse]: ...
    async def remove_coin_subscriptions(self, coinIds: Optional[List[bytes]] = None) -> Awaitable[List[bytes]]: ...
    async def remove_puzzle_subscriptions(self, puzzleHashes: Optional[List[bytes]] = None) -> Awaitable[List[bytes]]: ...
    async def next(self) -> Awaitable[Optional[Event]]: ...
class Event:
    def clone(self) -> Event: ...
    new_peak_wallet: Optional[NewPeakWallet]
    coin_state_update: Optional[CoinStateUpdate]
class NewPeakWallet:
    def clone(self) -> NewPeakWallet: ...
    def __init__(self, headerHash: bytes, height: int, weight: int, forkPointWithPreviousPeak: int) -> None: ...
    header_hash: bytes
    height: int
    weight: int
    fork_point_with_previous_peak: int
class CoinStateUpdate:
    def clone(self) -> CoinStateUpdate: ...
    def __init__(self, height: int, forkHeight: int, peakHash: bytes, items: List[CoinState]) -> None: ...
    height: int
    fork_height: int
    peak_hash: bytes
    items: List[CoinState]
class CoinState:
    def clone(self) -> CoinState: ...
    def __init__(self, coin: Coin, spentHeight: Optional[int] = None, createdHeight: Optional[int] = None) -> None: ...
    coin: Coin
    spent_height: Optional[int]
    created_height: Optional[int]
class RespondCoinState:
    def clone(self) -> RespondCoinState: ...
    def __init__(self, coinIds: List[bytes], coinStates: List[CoinState]) -> None: ...
    coin_ids: List[bytes]
    coin_states: List[CoinState]
class RespondPuzzleState:
    def clone(self) -> RespondPuzzleState: ...
    def __init__(self, puzzleHashes: List[bytes], height: int, headerHash: bytes, isFinished: bool, coinStates: List[CoinState]) -> None: ...
    puzzle_hashes: List[bytes]
    height: int
    header_hash: bytes
    is_finished: bool
    coin_states: List[CoinState]
class PuzzleSolutionResponse:
    def clone(self) -> PuzzleSolutionResponse: ...
    def __init__(self, coinName: bytes, height: int, puzzle: bytes, solution: bytes) -> None: ...
    coin_name: bytes
    height: int
    puzzle: bytes
    solution: bytes
class CoinStateFilters:
    def clone(self) -> CoinStateFilters: ...
    def __init__(self, includeSpent: bool, includeUnspent: bool, includeHinted: bool, minAmount: int) -> None: ...
    include_spent: bool
    include_unspent: bool
    include_hinted: bool
    min_amount: int
class Program:
    def clone(self) -> Program: ...
    def compile(self) -> Output: ...
    def unparse(self) -> str: ...
    def serialize(self) -> bytes: ...
    def serialize_with_backrefs(self) -> bytes: ...
    def run(self, solution: Program, maxCost: int, mempoolMode: bool) -> Output: ...
    def curry(self, args: List[Program]) -> Program: ...
    def uncurry(self) -> Optional[CurriedProgram]: ...
    def tree_hash(self) -> bytes: ...
    def is_atom(self) -> bool: ...
    def is_pair(self) -> bool: ...
    def is_null(self) -> bool: ...
    def length(self) -> int: ...
    def first(self) -> Program: ...
    def rest(self) -> Program: ...
    def to_int(self) -> Optional[int]: ...
    def to_bound_checked_number(self) -> Optional[float]: ...
    def to_string(self) -> Optional[str]: ...
    def to_bool(self) -> Optional[bool]: ...
    def to_atom(self) -> Optional[bytes]: ...
    def to_list(self) -> Optional[List[Program]]: ...
    def to_pair(self) -> Optional[Pair]: ...
    def puzzle(self) -> Puzzle: ...
    def parse_nft_metadata(self) -> Optional[NftMetadata]: ...
    def parse_remark(self) -> Optional[Remark]: ...
    def parse_agg_sig_parent(self) -> Optional[AggSigParent]: ...
    def parse_agg_sig_puzzle(self) -> Optional[AggSigPuzzle]: ...
    def parse_agg_sig_amount(self) -> Optional[AggSigAmount]: ...
    def parse_agg_sig_puzzle_amount(self) -> Optional[AggSigPuzzleAmount]: ...
    def parse_agg_sig_parent_amount(self) -> Optional[AggSigParentAmount]: ...
    def parse_agg_sig_parent_puzzle(self) -> Optional[AggSigParentPuzzle]: ...
    def parse_agg_sig_unsafe(self) -> Optional[AggSigUnsafe]: ...
    def parse_agg_sig_me(self) -> Optional[AggSigMe]: ...
    def parse_create_coin(self) -> Optional[CreateCoin]: ...
    def parse_reserve_fee(self) -> Optional[ReserveFee]: ...
    def parse_create_coin_announcement(self) -> Optional[CreateCoinAnnouncement]: ...
    def parse_create_puzzle_announcement(self) -> Optional[CreatePuzzleAnnouncement]: ...
    def parse_assert_coin_announcement(self) -> Optional[AssertCoinAnnouncement]: ...
    def parse_assert_puzzle_announcement(self) -> Optional[AssertPuzzleAnnouncement]: ...
    def parse_assert_concurrent_spend(self) -> Optional[AssertConcurrentSpend]: ...
    def parse_assert_concurrent_puzzle(self) -> Optional[AssertConcurrentPuzzle]: ...
    def parse_assert_seconds_relative(self) -> Optional[AssertSecondsRelative]: ...
    def parse_assert_seconds_absolute(self) -> Optional[AssertSecondsAbsolute]: ...
    def parse_assert_height_relative(self) -> Optional[AssertHeightRelative]: ...
    def parse_assert_height_absolute(self) -> Optional[AssertHeightAbsolute]: ...
    def parse_assert_before_seconds_relative(self) -> Optional[AssertBeforeSecondsRelative]: ...
    def parse_assert_before_seconds_absolute(self) -> Optional[AssertBeforeSecondsAbsolute]: ...
    def parse_assert_before_height_relative(self) -> Optional[AssertBeforeHeightRelative]: ...
    def parse_assert_before_height_absolute(self) -> Optional[AssertBeforeHeightAbsolute]: ...
    def parse_assert_my_coin_id(self) -> Optional[AssertMyCoinId]: ...
    def parse_assert_my_parent_id(self) -> Optional[AssertMyParentId]: ...
    def parse_assert_my_puzzle_hash(self) -> Optional[AssertMyPuzzleHash]: ...
    def parse_assert_my_amount(self) -> Optional[AssertMyAmount]: ...
    def parse_assert_my_birth_seconds(self) -> Optional[AssertMyBirthSeconds]: ...
    def parse_assert_my_birth_height(self) -> Optional[AssertMyBirthHeight]: ...
    def parse_assert_ephemeral(self) -> Optional[AssertEphemeral]: ...
    def parse_send_message(self) -> Optional[SendMessage]: ...
    def parse_receive_message(self) -> Optional[ReceiveMessage]: ...
    def parse_softfork(self) -> Optional[Softfork]: ...
    def parse_melt_singleton(self) -> Optional[MeltSingleton]: ...
    def parse_transfer_nft(self) -> Optional[TransferNft]: ...
    def parse_run_cat_tail(self) -> Optional[RunCatTail]: ...
    def parse_update_nft_metadata(self) -> Optional[UpdateNftMetadata]: ...
    def parse_update_data_store_merkle_root(self) -> Optional[UpdateDataStoreMerkleRoot]: ...
    def parse_option_metadata(self) -> Optional[OptionMetadata]: ...
    def parse_payment(self) -> Optional[Payment]: ...
    def parse_notarized_payment(self) -> Optional[NotarizedPayment]: ...
    def parse_reward_distributor_launcher_solution(self, launcherCoin: Coin) -> Optional[RewardDistributorLauncherSolutionInfo]: ...
class Puzzle:
    def clone(self) -> Puzzle: ...
    def __init__(self, puzzleHash: bytes, program: Program, modHash: bytes, args: Optional[Program] = None) -> None: ...
    puzzle_hash: bytes
    program: Program
    mod_hash: bytes
    args: Optional[Program]
    def parse_cat_info(self) -> Optional[ParsedCatInfo]: ...
    def parse_cat(self, coin: Coin, solution: Program) -> Optional[ParsedCat]: ...
    def parse_child_cats(self, parentCoin: Coin, parentSolution: Program) -> Optional[List[Cat]]: ...
    def parse_nft_info(self) -> Optional[ParsedNftInfo]: ...
    def parse_nft(self, coin: Coin, solution: Program) -> Optional[ParsedNft]: ...
    def parse_child_nft(self, parentCoin: Coin, parentSolution: Program) -> Optional[Nft]: ...
    def parse_did_info(self) -> Optional[ParsedDidInfo]: ...
    def parse_did(self, coin: Coin, solution: Program) -> Optional[ParsedDid]: ...
    def parse_child_did(self, parentCoin: Coin, parentSolution: Program, coin: Coin) -> Optional[Did]: ...
    def parse_option_info(self) -> Optional[ParsedOptionInfo]: ...
    def parse_option(self, coin: Coin, solution: Program) -> Optional[ParsedOption]: ...
    def parse_child_option(self, parentCoin: Coin, parentSolution: Program) -> Optional[OptionContract]: ...
    def parse_inner_streaming_puzzle(self) -> Optional[StreamingPuzzleInfo]: ...
    def parse_child_clawbacks(self, parentSolution: Program) -> Optional[List[Clawback]]: ...
class StreamedAssetParsingResult:
    def clone(self) -> StreamedAssetParsingResult: ...
    def __init__(self, streamedAsset: Optional[StreamedAsset], lastSpendWasClawback: bool, lastPaymentAmountIfClawback: int) -> None: ...
    streamed_asset: Optional[StreamedAsset]
    last_spend_was_clawback: bool
    last_payment_amount_if_clawback: int
class Cat:
    def clone(self) -> Cat: ...
    def __init__(self, coin: Coin, lineageProof: Optional[LineageProof], info: CatInfo) -> None: ...
    coin: Coin
    lineage_proof: Optional[LineageProof]
    info: CatInfo
    def child_lineage_proof(self) -> LineageProof: ...
    def child(self, p2PuzzleHash: bytes, amount: int) -> Cat: ...
    def unrevocable_child(self, p2PuzzleHash: bytes, amount: int) -> Cat: ...
class CatInfo:
    def clone(self) -> CatInfo: ...
    def __init__(self, assetId: bytes, hiddenPuzzleHash: Optional[bytes], p2PuzzleHash: bytes) -> None: ...
    asset_id: bytes
    hidden_puzzle_hash: Optional[bytes]
    p2_puzzle_hash: bytes
    def inner_puzzle_hash(self) -> bytes: ...
    def puzzle_hash(self) -> bytes: ...
class CatSpend:
    def clone(self) -> CatSpend: ...
    cat: Cat
    spend: Spend
    hidden: bool
    def __init__(self, cat: Cat, spend: Spend) -> None: ...
    @staticmethod
    def revoke(cat: Cat, spend: Spend) -> CatSpend: ...
class ParsedCatInfo:
    def clone(self) -> ParsedCatInfo: ...
    def __init__(self, info: CatInfo, p2Puzzle: Optional[Puzzle] = None) -> None: ...
    info: CatInfo
    p2_puzzle: Optional[Puzzle]
class ParsedCat:
    def clone(self) -> ParsedCat: ...
    def __init__(self, cat: Cat, p2Puzzle: Puzzle, p2Solution: Program) -> None: ...
    cat: Cat
    p2_puzzle: Puzzle
    p2_solution: Program
class Nft:
    def clone(self) -> Nft: ...
    def __init__(self, coin: Coin, proof: Proof, info: NftInfo) -> None: ...
    coin: Coin
    proof: Proof
    info: NftInfo
    def child_proof(self) -> Proof: ...
    def child(self, p2PuzzleHash: bytes, currentOwner: Optional[bytes], metadata: Program) -> Nft: ...
    def child_with(self, info: NftInfo) -> Nft: ...
class NftInfo:
    def clone(self) -> NftInfo: ...
    def __init__(self, launcherId: bytes, metadata: Program, metadataUpdaterPuzzleHash: bytes, currentOwner: Optional[bytes], royaltyPuzzleHash: bytes, royaltyBasisPoints: int, p2PuzzleHash: bytes) -> None: ...
    launcher_id: bytes
    metadata: Program
    metadata_updater_puzzle_hash: bytes
    current_owner: Optional[bytes]
    royalty_puzzle_hash: bytes
    royalty_basis_points: int
    p2_puzzle_hash: bytes
    def inner_puzzle_hash(self) -> bytes: ...
    def puzzle_hash(self) -> bytes: ...
class ParsedNftInfo:
    def clone(self) -> ParsedNftInfo: ...
    def __init__(self, info: NftInfo, p2Puzzle: Puzzle) -> None: ...
    info: NftInfo
    p2_puzzle: Puzzle
class ParsedNft:
    def clone(self) -> ParsedNft: ...
    def __init__(self, nft: Nft, p2Puzzle: Puzzle, p2Solution: Program) -> None: ...
    nft: Nft
    p2_puzzle: Puzzle
    p2_solution: Program
class NftMetadata:
    def clone(self) -> NftMetadata: ...
    def __init__(self, editionNumber: int, editionTotal: int, dataUris: List[str], dataHash: Optional[bytes], metadataUris: List[str], metadataHash: Optional[bytes], licenseUris: List[str], licenseHash: Optional[bytes] = None) -> None: ...
    edition_number: int
    edition_total: int
    data_uris: List[str]
    data_hash: Optional[bytes]
    metadata_uris: List[str]
    metadata_hash: Optional[bytes]
    license_uris: List[str]
    license_hash: Optional[bytes]
class NftMint:
    def clone(self) -> NftMint: ...
    def __init__(self, metadata: Program, metadataUpdaterPuzzleHash: bytes, p2PuzzleHash: bytes, royaltyPuzzleHash: bytes, royaltyBasisPoints: int, transferCondition: Optional[TransferNft] = None) -> None: ...
    metadata: Program
    metadata_updater_puzzle_hash: bytes
    p2_puzzle_hash: bytes
    royalty_puzzle_hash: bytes
    royalty_basis_points: int
    transfer_condition: Optional[TransferNft]
class MintedNfts:
    def clone(self) -> MintedNfts: ...
    def __init__(self, nfts: List[Nft], parentConditions: List[Program]) -> None: ...
    nfts: List[Nft]
    parent_conditions: List[Program]
class Did:
    def clone(self) -> Did: ...
    def __init__(self, coin: Coin, proof: Proof, info: DidInfo) -> None: ...
    coin: Coin
    proof: Proof
    info: DidInfo
    def child_proof(self) -> Proof: ...
    def child(self, p2PuzzleHash: bytes, metadata: Program) -> Did: ...
    def child_with(self, info: DidInfo) -> Did: ...
class DidInfo:
    def clone(self) -> DidInfo: ...
    def __init__(self, launcherId: bytes, recoveryListHash: Optional[bytes], numVerificationsRequired: int, metadata: Program, p2PuzzleHash: bytes) -> None: ...
    launcher_id: bytes
    recovery_list_hash: Optional[bytes]
    num_verifications_required: int
    metadata: Program
    p2_puzzle_hash: bytes
    def inner_puzzle_hash(self) -> bytes: ...
    def puzzle_hash(self) -> bytes: ...
class ParsedDidInfo:
    def clone(self) -> ParsedDidInfo: ...
    def __init__(self, info: DidInfo, p2Puzzle: Puzzle) -> None: ...
    info: DidInfo
    p2_puzzle: Puzzle
class ParsedDid:
    def clone(self) -> ParsedDid: ...
    def __init__(self, did: Did, p2Spend: Optional[ParsedDidSpend] = None) -> None: ...
    did: Did
    p2_spend: Optional[ParsedDidSpend]
class ParsedDidSpend:
    def clone(self) -> ParsedDidSpend: ...
    def __init__(self, puzzle: Puzzle, solution: Program) -> None: ...
    puzzle: Puzzle
    solution: Program
class CreatedDid:
    def clone(self) -> CreatedDid: ...
    def __init__(self, did: Did, parentConditions: List[Program]) -> None: ...
    did: Did
    parent_conditions: List[Program]
class OptionContract:
    def clone(self) -> OptionContract: ...
    def __init__(self, coin: Coin, proof: Proof, info: OptionInfo) -> None: ...
    coin: Coin
    proof: Proof
    info: OptionInfo
class OptionInfo:
    def clone(self) -> OptionInfo: ...
    def __init__(self, launcherId: bytes, underlyingCoinId: bytes, underlyingDelegatedPuzzleHash: bytes, p2PuzzleHash: bytes) -> None: ...
    launcher_id: bytes
    underlying_coin_id: bytes
    underlying_delegated_puzzle_hash: bytes
    p2_puzzle_hash: bytes
    def inner_puzzle_hash(self) -> bytes: ...
    def puzzle_hash(self) -> bytes: ...
class ParsedOptionInfo:
    def clone(self) -> ParsedOptionInfo: ...
    def __init__(self, info: OptionInfo, p2Puzzle: Puzzle) -> None: ...
    info: OptionInfo
    p2_puzzle: Puzzle
class ParsedOption:
    def clone(self) -> ParsedOption: ...
    def __init__(self, option: OptionContract, p2Puzzle: Puzzle, p2Solution: Program) -> None: ...
    option: OptionContract
    p2_puzzle: Puzzle
    p2_solution: Program
class OptionUnderlying:
    def clone(self) -> OptionUnderlying: ...
    def __init__(self, launcherId: bytes, creatorPuzzleHash: bytes, seconds: int, amount: int, strikeType: OptionType) -> None: ...
    launcher_id: bytes
    creator_puzzle_hash: bytes
    seconds: int
    amount: int
    strike_type: OptionType
    def exercise_spend(self, clvm: Clvm, singletonInnerPuzzleHash: bytes, singletonAmount: int) -> Spend: ...
    def clawback_spend(self, spend: Spend) -> Spend: ...
    def puzzle_hash(self) -> bytes: ...
    def delegated_puzzle_hash(self) -> bytes: ...
class OptionMetadata:
    def clone(self) -> OptionMetadata: ...
    def __init__(self, expirationSeconds: int, strikeType: OptionType) -> None: ...
    expiration_seconds: int
    strike_type: OptionType
class OptionType:
    def clone(self) -> OptionType: ...
    @staticmethod
    def xch(amount: int) -> OptionType: ...
    @staticmethod
    def cat(assetId: bytes, amount: int) -> OptionType: ...
    @staticmethod
    def revocable_cat(assetId: bytes, hiddenPuzzleHash: bytes, amount: int) -> OptionType: ...
    @staticmethod
    def nft(launcherId: bytes, settlementPuzzleHash: bytes, amount: int) -> OptionType: ...
    def to_xch(self) -> Optional[OptionTypeXch]: ...
    def to_cat(self) -> Optional[OptionTypeCat]: ...
    def to_revocable_cat(self) -> Optional[OptionTypeRevocableCat]: ...
    def to_nft(self) -> Optional[OptionTypeNft]: ...
class OptionTypeXch:
    def clone(self) -> OptionTypeXch: ...
    amount: int
class OptionTypeCat:
    def clone(self) -> OptionTypeCat: ...
    asset_id: bytes
    amount: int
class OptionTypeRevocableCat:
    def clone(self) -> OptionTypeRevocableCat: ...
    asset_id: bytes
    hidden_puzzle_hash: bytes
    amount: int
class OptionTypeNft:
    def clone(self) -> OptionTypeNft: ...
    launcher_id: bytes
    settlement_puzzle_hash: bytes
    amount: int
class StreamingPuzzleInfo:
    def clone(self) -> StreamingPuzzleInfo: ...
    def __init__(self, recipient: bytes, clawbackPh: Optional[bytes], endTime: int, lastPaymentTime: int) -> None: ...
    recipient: bytes
    clawback_ph: Optional[bytes]
    end_time: int
    last_payment_time: int
    def amount_to_be_paid(self, myCoinAmount: int, paymentTime: int) -> int: ...
    @staticmethod
    def get_hint(recipient: bytes) -> bytes: ...
    def get_launch_hints(self) -> List[bytes]: ...
    def inner_puzzle_hash(self) -> bytes: ...
    @staticmethod
    def from_memos(memos: List[bytes]) -> Optional[StreamingPuzzleInfo]: ...
class StreamedAsset:
    def clone(self) -> StreamedAsset: ...
    def __init__(self, coin: Coin, assetId: Optional[bytes], proof: Optional[LineageProof], info: StreamingPuzzleInfo) -> None: ...
    coin: Coin
    asset_id: Optional[bytes]
    proof: Optional[LineageProof]
    info: StreamingPuzzleInfo
    @staticmethod
    def xch(coin: Coin, info: StreamingPuzzleInfo) -> StreamedAsset: ...
    @staticmethod
    def cat(coin: Coin, assetId: bytes, proof: LineageProof, info: StreamingPuzzleInfo) -> StreamedAsset: ...
class ClawbackV2:
    def clone(self) -> ClawbackV2: ...
    def __init__(self, senderPuzzleHash: bytes, receiverPuzzleHash: bytes, seconds: int, amount: int, hinted: bool) -> None: ...
    sender_puzzle_hash: bytes
    receiver_puzzle_hash: bytes
    seconds: int
    amount: int
    hinted: bool
    @staticmethod
    def from_memo(memo: Program, receiverPuzzleHash: bytes, amount: int, hinted: bool, expectedPuzzleHash: bytes) -> Optional[ClawbackV2]: ...
    def sender_spend(self, spend: Spend) -> Spend: ...
    def receiver_spend(self, spend: Spend) -> Spend: ...
    def push_through_spend(self, clvm: Clvm) -> Spend: ...
    def puzzle_hash(self) -> bytes: ...
    def memo(self, clvm: Clvm) -> Program: ...
class Clawback:
    def clone(self) -> Clawback: ...
    def __init__(self, timelock: int, senderPuzzleHash: bytes, receiverPuzzleHash: bytes) -> None: ...
    timelock: int
    sender_puzzle_hash: bytes
    receiver_puzzle_hash: bytes
    def sender_spend(self, spend: Spend) -> Spend: ...
    def receiver_spend(self, spend: Spend) -> Spend: ...
    def puzzle_hash(self) -> bytes: ...
    def get_remark_condition(self, clvm: Clvm) -> Remark: ...
class MedievalVaultHint:
    def clone(self) -> MedievalVaultHint: ...
    def __init__(self, myLauncherId: bytes, m: usize, publicKeyList: List[PublicKey]) -> None: ...
    my_launcher_id: bytes
    m: usize
    public_key_list: List[PublicKey]
class MedievalVaultInfo:
    def clone(self) -> MedievalVaultInfo: ...
    def __init__(self, launcherId: bytes, m: usize, publicKeyList: List[PublicKey]) -> None: ...
    launcher_id: bytes
    m: usize
    public_key_list: List[PublicKey]
    def inner_puzzle_hash(self) -> bytes: ...
    def puzzle_hash(self) -> bytes: ...
    @staticmethod
    def from_hint(hint: MedievalVaultHint) -> MedievalVaultInfo: ...
    def to_hint(self) -> MedievalVaultHint: ...
class MedievalVault:
    def clone(self) -> MedievalVault: ...
    def __init__(self, coin: Coin, proof: Proof, info: MedievalVaultInfo) -> None: ...
    coin: Coin
    proof: Proof
    info: MedievalVaultInfo
    def child(self, newM: usize, newPublicKeyList: List[PublicKey]) -> MedievalVault: ...
class RewardDistributorType(IntEnum):
    Manager = 0
    Nft = 1
class RewardDistributorConstants:
    def clone(self) -> RewardDistributorConstants: ...
    def __init__(self, launcherId: bytes, rewardDistributorType: RewardDistributorType, managerOrCollectionDidLauncherId: bytes, feePayoutPuzzleHash: bytes, epochSeconds: int, maxSecondsOffset: int, payoutThreshold: int, feeBps: int, withdrawalShareBps: int, reserveAssetId: bytes, reserveInnerPuzzleHash: bytes, reserveFullPuzzleHash: bytes) -> None: ...
    launcher_id: bytes
    reward_distributor_type: RewardDistributorType
    manager_or_collection_did_launcher_id: bytes
    fee_payout_puzzle_hash: bytes
    epoch_seconds: int
    max_seconds_offset: int
    payout_threshold: int
    fee_bps: int
    withdrawal_share_bps: int
    reserve_asset_id: bytes
    reserve_inner_puzzle_hash: bytes
    reserve_full_puzzle_hash: bytes
    @staticmethod
    def without_launcher_id(rewardDistributorType: RewardDistributorType, managerOrCollectionDidLauncherId: bytes, feePayoutPuzzleHash: bytes, epochSeconds: int, maxSecondsOffset: int, payoutThreshold: int, feeBps: int, withdrawalShareBps: int, reserveAssetId: bytes) -> RewardDistributorConstants: ...
    def with_launcher_id(self, launcherId: bytes) -> RewardDistributorConstants: ...
class RoundRewardInfo:
    def clone(self) -> RoundRewardInfo: ...
    def __init__(self, cumulativePayout: int, remainingRewards: int) -> None: ...
    cumulative_payout: int
    remaining_rewards: int
class RoundTimeInfo:
    def clone(self) -> RoundTimeInfo: ...
    def __init__(self, lastUpdate: int, epochEnd: int) -> None: ...
    last_update: int
    epoch_end: int
class RewardDistributorState:
    def clone(self) -> RewardDistributorState: ...
    def __init__(self, totalReserves: int, activeShares: int, roundRewardInfo: RoundRewardInfo, roundTimeInfo: RoundTimeInfo) -> None: ...
    total_reserves: int
    active_shares: int
    round_reward_info: RoundRewardInfo
    round_time_info: RoundTimeInfo
class RewardDistributorLauncherSolutionInfo:
    def clone(self) -> RewardDistributorLauncherSolutionInfo: ...
    def __init__(self, constants: RewardDistributorConstants, initialState: RewardDistributorState, coin: Coin) -> None: ...
    constants: RewardDistributorConstants
    initial_state: RewardDistributorState
    coin: Coin
class RewardDistributorFinishedSpendResult:
    def clone(self) -> RewardDistributorFinishedSpendResult: ...
    def __init__(self, newDistributor: RewardDistributor, signature: Signature) -> None: ...
    new_distributor: RewardDistributor
    signature: Signature
class RewardDistributorRewardSlotValue:
    def clone(self) -> RewardDistributorRewardSlotValue: ...
    def __init__(self, epochStart: int, nextEpochInitialized: bool, rewards: int) -> None: ...
    epoch_start: int
    next_epoch_initialized: bool
    rewards: int
class RewardSlot:
    def clone(self) -> RewardSlot: ...
    coin: Coin
    proof: LineageProof
    nonce: int
    launcher_id: bytes
    value: RewardDistributorRewardSlotValue
    @staticmethod
    def new(proof: LineageProof, launcherId: bytes, value: RewardDistributorRewardSlotValue) -> RewardSlot: ...
    def value_hash(self) -> bytes: ...
class RewardDistributorCommitmentSlotValue:
    def clone(self) -> RewardDistributorCommitmentSlotValue: ...
    def __init__(self, epochStart: int, clawbackPh: bytes, rewards: int) -> None: ...
    epoch_start: int
    clawback_ph: bytes
    rewards: int
class CommitmentSlot:
    def clone(self) -> CommitmentSlot: ...
    coin: Coin
    proof: LineageProof
    nonce: int
    launcher_id: bytes
    value: RewardDistributorCommitmentSlotValue
    @staticmethod
    def new(proof: LineageProof, launcherId: bytes, value: RewardDistributorCommitmentSlotValue) -> CommitmentSlot: ...
    def value_hash(self) -> bytes: ...
class RewardDistributorEntrySlotValue:
    def clone(self) -> RewardDistributorEntrySlotValue: ...
    def __init__(self, payoutPuzzleHash: bytes, initialCumulativePayout: int, shares: int) -> None: ...
    payout_puzzle_hash: bytes
    initial_cumulative_payout: int
    shares: int
class EntrySlot:
    def clone(self) -> EntrySlot: ...
    coin: Coin
    proof: LineageProof
    nonce: int
    launcher_id: bytes
    value: RewardDistributorEntrySlotValue
    @staticmethod
    def new(proof: LineageProof, launcherId: bytes, value: RewardDistributorEntrySlotValue) -> EntrySlot: ...
    def value_hash(self) -> bytes: ...
class RewardDistributorInitiatePayoutResult:
    def clone(self) -> RewardDistributorInitiatePayoutResult: ...
    conditions: List[Program]
    payout_amount: int
class RewardDistributorNewEpochResult:
    def clone(self) -> RewardDistributorNewEpochResult: ...
    conditions: List[Program]
    epoch_fee: int
class RewardDistributorWithdrawIncentivesResult:
    def clone(self) -> RewardDistributorWithdrawIncentivesResult: ...
    conditions: List[Program]
    withdrawn_amount: int
class RewardDistributorRemoveEntryResult:
    def clone(self) -> RewardDistributorRemoveEntryResult: ...
    conditions: List[Program]
    last_payment_amount: int
class IntermediaryCoinProof:
    def clone(self) -> IntermediaryCoinProof: ...
    def __init__(self, fullPuzzleHash: bytes, amount: int) -> None: ...
    full_puzzle_hash: bytes
    amount: int
class NftLauncherProof:
    def clone(self) -> NftLauncherProof: ...
    def __init__(self, didProof: LineageProof, intermediaryCoinProofs: List[IntermediaryCoinProof]) -> None: ...
    did_proof: LineageProof
    intermediary_coin_proofs: List[IntermediaryCoinProof]
class RewardDistributorStakeResult:
    def clone(self) -> RewardDistributorStakeResult: ...
    conditions: List[Program]
    notarized_payment: NotarizedPayment
    new_nft: Nft
class RewardDistributorUnstakeResult:
    def clone(self) -> RewardDistributorUnstakeResult: ...
    conditions: List[Program]
    payment_amount: int
class RewardDistributorLaunchResult:
    def clone(self) -> RewardDistributorLaunchResult: ...
    def __init__(self, securitySignature: Signature, securitySecretKey: SecretKey, rewardDistributor: RewardDistributor, firstEpochSlot: RewardSlot, refundedCat: Cat) -> None: ...
    security_signature: Signature
    security_secret_key: SecretKey
    reward_distributor: RewardDistributor
    first_epoch_slot: RewardSlot
    refunded_cat: Cat
class RewardDistributorInfoFromLauncher:
    def clone(self) -> RewardDistributorInfoFromLauncher: ...
    def __init__(self, constants: RewardDistributorConstants, initialState: RewardDistributorState, eveSingleton: Coin) -> None: ...
    constants: RewardDistributorConstants
    initial_state: RewardDistributorState
    eve_singleton: Coin
class RewardDistributorInfoFromEveCoin:
    def clone(self) -> RewardDistributorInfoFromEveCoin: ...
    def __init__(self, distributor: RewardDistributor, firstRewardSlot: RewardSlot) -> None: ...
    distributor: RewardDistributor
    first_reward_slot: RewardSlot
class RewardDistributor:
    def clone(self) -> RewardDistributor: ...
    def coin(self) -> Coin: ...
    def proof(self) -> Proof: ...
    def state(self) -> RewardDistributorState: ...
    def constants(self) -> RewardDistributorConstants: ...
    def inner_puzzle_hash(self) -> bytes: ...
    def puzzle_hash(self) -> bytes: ...
    def reserve_coin(self) -> Coin: ...
    def reserve_asset_id(self) -> bytes: ...
    def reserve_proof(self) -> LineageProof: ...
    def pending_created_reward_slots(self) -> List[RewardSlot]: ...
    def pending_created_commitment_slots(self) -> List[CommitmentSlot]: ...
    def pending_created_entry_slots(self) -> List[EntrySlot]: ...
    def pending_signature(self) -> Signature: ...
    @staticmethod
    def reserve_full_puzzle_hash(assetId: bytes, distributorLauncherId: bytes, nonce: int) -> bytes: ...
    @staticmethod
    def parse_launcher_solution(launcherCoin: Coin, launcherSolution: Program) -> Optional[RewardDistributorInfoFromLauncher]: ...
    def finish_spend(self, otherCatSpends: List[CatSpend]) -> RewardDistributorFinishedSpendResult: ...
    def add_incentives(self, amount: int) -> List[Program]: ...
    def commit_incentives(self, rewardSlot: RewardSlot, epochStart: int, clawbackPh: bytes, rewardsToAdd: int) -> List[Program]: ...
    def initiate_payout(self, entrySlot: EntrySlot) -> RewardDistributorInitiatePayoutResult: ...
    def new_epoch(self, rewardSlot: RewardSlot) -> RewardDistributorNewEpochResult: ...
    def sync(self, updateTime: int) -> List[Program]: ...
    def withdraw_incentives(self, commitmentSlot: CommitmentSlot, rewardSlot: RewardSlot) -> RewardDistributorWithdrawIncentivesResult: ...
    def add_entry(self, payoutPuzzleHash: bytes, shares: int, managerSingletonInnerPuzzleHash: bytes) -> List[Program]: ...
    def remove_entry(self, entrySlot: EntrySlot, managerSingletonInnerPuzzleHash: bytes) -> RewardDistributorRemoveEntryResult: ...
    def stake(self, currentNft: Nft, nftLauncherProof: NftLauncherProof, entryCustodyPuzzleHash: bytes) -> RewardDistributorStakeResult: ...
    def unstake(self, entrySlot: EntrySlot, lockedNft: Nft) -> RewardDistributorUnstakeResult: ...
    @staticmethod
    def locked_nft_hint(distributorLauncherId: bytes, custodyPuzzleHash: bytes) -> bytes: ...
class K1SecretKey:
    def clone(self) -> K1SecretKey: ...
    @staticmethod
    def from_bytes(bytes: bytes) -> K1SecretKey: ...
    def to_bytes(self) -> bytes: ...
    def public_key(self) -> K1PublicKey: ...
    def sign_prehashed(self, prehashed: bytes) -> K1Signature: ...
class K1PublicKey:
    def clone(self) -> K1PublicKey: ...
    @staticmethod
    def from_bytes(bytes: bytes) -> K1PublicKey: ...
    def to_bytes(self) -> bytes: ...
    def fingerprint(self) -> int: ...
    def verify_prehashed(self, prehashed: bytes, signature: K1Signature) -> bool: ...
class K1Signature:
    def clone(self) -> K1Signature: ...
    @staticmethod
    def from_bytes(bytes: bytes) -> K1Signature: ...
    def to_bytes(self) -> bytes: ...
class R1SecretKey:
    def clone(self) -> R1SecretKey: ...
    @staticmethod
    def from_bytes(bytes: bytes) -> R1SecretKey: ...
    def to_bytes(self) -> bytes: ...
    def public_key(self) -> R1PublicKey: ...
    def sign_prehashed(self, prehashed: bytes) -> R1Signature: ...
class R1PublicKey:
    def clone(self) -> R1PublicKey: ...
    @staticmethod
    def from_bytes(bytes: bytes) -> R1PublicKey: ...
    def to_bytes(self) -> bytes: ...
    def fingerprint(self) -> int: ...
    def verify_prehashed(self, prehashed: bytes, signature: R1Signature) -> bool: ...
class R1Signature:
    def clone(self) -> R1Signature: ...
    @staticmethod
    def from_bytes(bytes: bytes) -> R1Signature: ...
    def to_bytes(self) -> bytes: ...
class Simulator:
    def clone(self) -> Simulator: ...
    def __init__(self) -> None: ...
    def new_coin(self, puzzleHash: bytes, amount: int) -> Coin: ...
    def bls(self, amount: int) -> BlsPairWithCoin: ...
    def spend_coins(self, coinSpends: List[CoinSpend], secretKeys: List[SecretKey]) -> None: ...
    def pass_time(self, time: int) -> None: ...
class BlsPair:
    def clone(self) -> BlsPair: ...
    def __init__(self, sk: SecretKey, pk: PublicKey) -> None: ...
    sk: SecretKey
    pk: PublicKey
    @staticmethod
    def from_seed(seed: int) -> BlsPair: ...
    @staticmethod
    def many_from_seed(seed: int, count: int) -> List[BlsPair]: ...
class BlsPairWithCoin:
    def clone(self) -> BlsPairWithCoin: ...
    def __init__(self, sk: SecretKey, pk: PublicKey, puzzleHash: bytes, coin: Coin) -> None: ...
    sk: SecretKey
    pk: PublicKey
    puzzle_hash: bytes
    coin: Coin
class K1Pair:
    def clone(self) -> K1Pair: ...
    def __init__(self, sk: K1SecretKey, pk: K1PublicKey) -> None: ...
    sk: K1SecretKey
    pk: K1PublicKey
    @staticmethod
    def from_seed(seed: int) -> K1Pair: ...
    @staticmethod
    def many_from_seed(seed: int, count: int) -> List[K1Pair]: ...
class R1Pair:
    def clone(self) -> R1Pair: ...
    def __init__(self, sk: R1SecretKey, pk: R1PublicKey) -> None: ...
    sk: R1SecretKey
    pk: R1PublicKey
    @staticmethod
    def from_seed(seed: int) -> R1Pair: ...
    @staticmethod
    def many_from_seed(seed: int, count: int) -> List[R1Pair]: ...
